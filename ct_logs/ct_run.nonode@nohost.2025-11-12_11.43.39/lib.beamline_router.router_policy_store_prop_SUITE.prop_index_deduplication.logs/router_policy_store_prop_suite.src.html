<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/home/rustkas/aigroup/apps/otp/router/_build/test/lib/beamline_router/test/router_policy_store_prop_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%% @doc Property-based tests for router_policy_store</i>
<a name="2"/>    2: <i>%% Uses PropEr for randomized sequence of operations to detect race conditions</i>
<a name="3"/>    3: <b>-module</b>(router_policy_store_prop_SUITE).
<a name="4"/>    4: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="5"/>    5: 
<a name="6"/>    6: <i>%% Always include proper.hrl in test profile (PropEr is available in test profile)</i>
<a name="7"/>    7: <i>%% Runtime check for PropEr availability is done in prop_* functions</i>
<a name="8"/>    8: <b>-include_lib</b>(&quot;proper/include/proper.hrl&quot;).
<a name="9"/>    9: 
<a name="10"/>   10: <b>-compile</b>(export_all).
<a name="11"/>   11: 
<a name="12"/>   12: <b>-export</b>([all/0, init_per_suite/1, end_per_suite/1]).
<a name="13"/>   13: 
<a name="14"/>   14: <b>-include</b>(&quot;beamline_router.hrl&quot;).
<a name="15"/>   15: 
<a name="all-0"/><a name="16"/>   16: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="17"/>   17: <b>    case code:which</b>(proper) of
<a name="18"/>   18:         non_existing -&gt; [
<a name="19"/>   19:             prop_concurrent_operations_skip,
<a name="20"/>   20:             prop_upsert_delete_consistency_skip,
<a name="21"/>   21:             prop_list_policies_ordering_skip,
<a name="22"/>   22:             prop_index_consistency_skip,
<a name="23"/>   23:             prop_index_deduplication_skip
<a name="24"/>   24:         ];
<a name="25"/>   25:         _ -&gt; [
<a name="26"/>   26:             prop_concurrent_operations,
<a name="27"/>   27:             prop_upsert_delete_consistency,
<a name="28"/>   28:             prop_list_policies_ordering,
<a name="29"/>   29:             prop_index_consistency,
<a name="30"/>   30:             prop_index_deduplication
<a name="31"/>   31:         ]
<a name="32"/>   32:     end.
<a name="33"/>   33: 
<a name="init_per_suite-1"/><a name="34"/>   34: <b>init_per_suite</b>(Config) -&gt;
<a name="35"/>   35:     %% Start application with ephemeral port
<a name="36"/>   36:     _ = application:load(beamline_router),
<a name="37"/>   37:     ok = application:set_env(beamline_router, grpc_port, 0),
<a name="38"/>   38:     %% Disable heir/transfer logic for faster test execution
<a name="39"/>   39:     ok = application:set_env(beamline_router, disable_heir, true),
<a name="40"/>   40:     ok = application:set_env(beamline_router, grpc_enabled, false),
<a name="41"/>   41:     ok = application:set_env(beamline_router, nats_mode, mock),
<a name="init_per_suite-last_expr"/><a name="42"/>   42: <b>    case application:ensure_all_started</b>(beamline_router) of
<a name="43"/>   43:         {ok, _} -&gt;
<a name="44"/>   44:             Config;
<a name="45"/>   45:         Error -&gt;
<a name="46"/>   46:             ct:fail(&quot;Failed to start beamline_router: ~p&quot;, [Error])
<a name="47"/>   47:     end.
<a name="48"/>   48: 
<a name="end_per_suite-1"/><a name="49"/>   49: <b>end_per_suite</b>(_Config) -&gt;
<a name="50"/>   50:     application:stop(beamline_router),
<a name="end_per_suite-last_expr"/><a name="51"/>   51:     ok.
<a name="52"/>   52: 
<a name="53"/>   53: <i>%% Skip tests if PropEr not available</i>
<a name="prop_concurrent_operations_skip-1"/><a name="54"/>   54: <b>prop_concurrent_operations_skip</b>(_Config) -&gt;
<a name="prop_concurrent_operations_skip-last_expr"/><a name="55"/>   55:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_upsert_delete_consistency_skip-1"/><a name="56"/>   56: <b>prop_upsert_delete_consistency_skip</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency_skip-last_expr"/><a name="57"/>   57:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_list_policies_ordering_skip-1"/><a name="58"/>   58: <b>prop_list_policies_ordering_skip</b>(_Config) -&gt;
<a name="prop_list_policies_ordering_skip-last_expr"/><a name="59"/>   59:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_index_consistency_skip-1"/><a name="60"/>   60: <b>prop_index_consistency_skip</b>(_Config) -&gt;
<a name="prop_index_consistency_skip-last_expr"/><a name="61"/>   61:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_index_deduplication_skip-1"/><a name="62"/>   62: <b>prop_index_deduplication_skip</b>(_Config) -&gt;
<a name="prop_index_deduplication_skip-last_expr"/><a name="63"/>   63:     {skip, &quot;PropEr not available&quot;}.
<a name="64"/>   64: 
<a name="65"/>   65: <i>%% Property: Concurrent operations maintain consistency</i>
<a name="prop_concurrent_operations-1"/><a name="66"/>   66: <b>prop_concurrent_operations</b>(_Config) -&gt;
<a name="prop_concurrent_operations-last_expr"/><a name="67"/>   67: <b>    case code:which</b>(proper) of
<a name="68"/>   68:         non_existing -&gt;
<a name="69"/>   69:             {skip, &quot;PropEr not available&quot;};
<a name="70"/>   70:         _ -&gt;
<a name="71"/>   71:             Prop = ?FORALL(
<a name="72"/>   72:                 Operations,
<a name="73"/>   73:                 list(operation()),
<a name="74"/>   74:                 begin
<a name="75"/>   75:                     TenantId = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="76"/>   76:                     %% Execute operations sequentially (gen_server serializes)
<a name="77"/>   77:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="78"/>   78:                     
<a name="79"/>   79:                     %% Verify final state is consistent
<a name="80"/>   80:                     {ok, FinalPolicies} = router_policy_store:list_policies(TenantId),
<a name="81"/>   81:                     
<a name="82"/>   82:                     %% Check: all policies in list should be valid
<a name="83"/>   83:                     AllValid = lists:all(fun(P) -&gt;
<a name="84"/>   84:                         is_record(P, policy) andalso
<a name="85"/>   85:                         P#policy.tenant_id =:= TenantId
<a name="86"/>   86:                     end, FinalPolicies),
<a name="87"/>   87:                     
<a name="88"/>   88:                     %% Check: no duplicate policy_ids
<a name="89"/>   89:                     PolicyIds = [P#policy.policy_id || P &lt;- FinalPolicies],
<a name="90"/>   90:                     NoDuplicates = length(PolicyIds) =:= length(lists:usort(PolicyIds)),
<a name="91"/>   91:                     
<a name="92"/>   92:                     AllValid andalso NoDuplicates
<a name="93"/>   93:                 end
<a name="94"/>   94:             ),
<a name="95"/>   95:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="96"/>   96:             case Result of
<a name="97"/>   97:                 true -&gt; 
<a name="98"/>   98:                     ok;
<a name="99"/>   99:                 false -&gt;
<a name="100"/>  100:                     ct:fail(&quot;Property failed&quot;);
<a name="101"/>  101:                 {false, CounterExample} -&gt;
<a name="102"/>  102:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="103"/>  103:                 Other -&gt;
<a name="104"/>  104:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="105"/>  105:             end
<a name="106"/>  106:     end.
<a name="107"/>  107: 
<a name="108"/>  108: <i>%% Property: Upsert and delete maintain consistency</i>
<a name="prop_upsert_delete_consistency-1"/><a name="109"/>  109: <b>prop_upsert_delete_consistency</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency-last_expr"/><a name="110"/>  110: <b>    case code:which</b>(proper) of
<a name="111"/>  111:         non_existing -&gt;
<a name="112"/>  112:             {skip, &quot;PropEr not available&quot;};
<a name="113"/>  113:         _ -&gt;
<a name="114"/>  114:             Prop = ?FORALL(
<a name="115"/>  115:                 {Upserts, Deletes},
<a name="116"/>  116:                 {list(upsert_operation()), list(delete_operation())},
<a name="117"/>  117:                 begin
<a name="118"/>  118:                     TenantId = &lt;&lt;&quot;prop_consistency_tenant&quot;&gt;&gt;,
<a name="119"/>  119:                     
<a name="120"/>  120:                     %% Execute all upserts first
<a name="121"/>  121:                     [execute_operation(TenantId, Op) || Op &lt;- Upserts],
<a name="122"/>  122:                     
<a name="123"/>  123:                     %% Get policy IDs from upserts
<a name="124"/>  124:                     UpsertedIds = [Policy#policy.policy_id || {upsert, Policy} &lt;- Upserts],
<a name="125"/>  125:                     
<a name="126"/>  126:                     %% Execute all deletes
<a name="127"/>  127:                     [execute_operation(TenantId, Op) || Op &lt;- Deletes],
<a name="128"/>  128:                     
<a name="129"/>  129:                     %% Get deleted policy IDs
<a name="130"/>  130:                     DeletedIds = [PolicyId || {delete, PolicyId} &lt;- Deletes],
<a name="131"/>  131:                     
<a name="132"/>  132:                     %% Get final state
<a name="133"/>  133:                     {ok, Policies} = router_policy_store:list_policies(TenantId),
<a name="134"/>  134:                     FinalPolicyIds = [P#policy.policy_id || P &lt;- Policies],
<a name="135"/>  135:                     
<a name="136"/>  136:                     %% Check: policies that were deleted and NOT re-upserted should not be in final list
<a name="137"/>  137:                     %% A policy is truly deleted if it was deleted AND not re-upserted after deletion
<a name="138"/>  138:                     TrulyDeleted = [Id || Id &lt;- DeletedIds, not lists:member(Id, UpsertedIds)],
<a name="139"/>  139:                     
<a name="140"/>  140:                     %% Verify: truly deleted policies should not be in final list
<a name="141"/>  141:                     lists:all(fun(DeletedId) -&gt;
<a name="142"/>  142:                         not lists:member(DeletedId, FinalPolicyIds)
<a name="143"/>  143:                     end, TrulyDeleted)
<a name="144"/>  144:                 end
<a name="145"/>  145:             ),
<a name="146"/>  146:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="147"/>  147:             case Result of
<a name="148"/>  148:                 true -&gt; 
<a name="149"/>  149:                     ok;
<a name="150"/>  150:                 false -&gt;
<a name="151"/>  151:                     ct:fail(&quot;Property failed&quot;);
<a name="152"/>  152:                 {false, CounterExample} -&gt;
<a name="153"/>  153:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="154"/>  154:                 Other -&gt;
<a name="155"/>  155:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="156"/>  156:             end
<a name="157"/>  157:     end.
<a name="158"/>  158: 
<a name="159"/>  159: <i>%% Property: list_policies always returns sorted results</i>
<a name="prop_list_policies_ordering-1"/><a name="160"/>  160: <b>prop_list_policies_ordering</b>(_Config) -&gt;
<a name="prop_list_policies_ordering-last_expr"/><a name="161"/>  161: <b>    case code:which</b>(proper) of
<a name="162"/>  162:         non_existing -&gt;
<a name="163"/>  163:             {skip, &quot;PropEr not available&quot;};
<a name="164"/>  164:         _ -&gt;
<a name="165"/>  165:             Prop = ?FORALL(
<a name="166"/>  166:                 Policies,
<a name="167"/>  167:                 list(policy()),
<a name="168"/>  168:                 begin
<a name="169"/>  169:                     TenantId = &lt;&lt;&quot;prop_ordering_tenant&quot;&gt;&gt;,
<a name="170"/>  170:                     
<a name="171"/>  171:                     %% Clear existing policies
<a name="172"/>  172:                     {ok, Existing} = router_policy_store:list_policies(TenantId),
<a name="173"/>  173:                     [router_policy_store:delete_policy(TenantId, P#policy.policy_id) || P &lt;- Existing],
<a name="174"/>  174:                     
<a name="175"/>  175:                     %% Insert all policies
<a name="176"/>  176:                     [router_policy_store:upsert_policy(TenantId, P) || P &lt;- Policies],
<a name="177"/>  177:                     
<a name="178"/>  178:                     %% Get list
<a name="179"/>  179:                     {ok, Listed} = router_policy_store:list_policies(TenantId),
<a name="180"/>  180:                     
<a name="181"/>  181:                     %% Check: results are sorted by policy_id (lexicographic binary order)
<a name="182"/>  182:                     PolicyIds = [P#policy.policy_id || P &lt;- Listed],
<a name="183"/>  183:                     %% Use Erlang term ordering (&lt;) to match implementation
<a name="184"/>  184:                     Sorted = lists:sort(PolicyIds),
<a name="185"/>  185:                     
<a name="186"/>  186:                     PolicyIds =:= Sorted
<a name="187"/>  187:                 end
<a name="188"/>  188:             ),
<a name="189"/>  189:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="190"/>  190:             case Result of
<a name="191"/>  191:                 true -&gt; 
<a name="192"/>  192:                     ok;
<a name="193"/>  193:                 false -&gt;
<a name="194"/>  194:                     ct:fail(&quot;Property failed&quot;);
<a name="195"/>  195:                 {false, CounterExample} -&gt;
<a name="196"/>  196:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="197"/>  197:                 Other -&gt;
<a name="198"/>  198:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="199"/>  199:             end
<a name="200"/>  200:     end.
<a name="201"/>  201: 
<a name="202"/>  202: <i>%% Property: Secondary index maintains consistency with main table</i>
<a name="prop_index_consistency-1"/><a name="203"/>  203: <b>prop_index_consistency</b>(_Config) -&gt;
<a name="prop_index_consistency-last_expr"/><a name="204"/>  204: <b>    case code:which</b>(proper) of
<a name="205"/>  205:         non_existing -&gt;
<a name="206"/>  206:             {skip, &quot;PropEr not available&quot;};
<a name="207"/>  207:         _ -&gt;
<a name="208"/>  208:             Prop = ?FORALL(
<a name="209"/>  209:                 Operations,
<a name="210"/>  210:                 list(operation()),
<a name="211"/>  211:                 begin
<a name="212"/>  212:                     TenantId = &lt;&lt;&quot;prop_index_tenant&quot;&gt;&gt;,
<a name="213"/>  213:                     
<a name="214"/>  214:                     %% Execute operations
<a name="215"/>  215:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="216"/>  216:                     
<a name="217"/>  217:                     %% Get policies via list_policies (uses index)
<a name="218"/>  218:                     {ok, IndexedPolicies} = router_policy_store:list_policies(TenantId),
<a name="219"/>  219:                     IndexedIds = lists:sort([P#policy.policy_id || P &lt;- IndexedPolicies]),
<a name="220"/>  220:                     
<a name="221"/>  221:                     %% Get policies via direct lookup (bypasses index)
<a name="222"/>  222:                     AllKeys = ets:match(policy_store, {{TenantId, '$1'}, '_'}),
<a name="223"/>  223:                     DirectIds = lists:sort([Id || [Id] &lt;- AllKeys]),
<a name="224"/>  224:                     
<a name="225"/>  225:                     %% Check: index and direct lookup should match
<a name="226"/>  226:                     IndexConsistent = IndexedIds =:= DirectIds,
<a name="227"/>  227:                     
<a name="228"/>  228:                     %% Check: for each {TenantId, PolicyId} in main table, there's exactly one entry in index
<a name="229"/>  229:                     IndexTable = policy_store_index,
<a name="230"/>  230:                     AllIndexEntries = ets:match_object(IndexTable, {TenantId, '_'}),
<a name="231"/>  231:                     IndexPolicyIds = lists:sort([PolicyId || {_TenantId, PolicyId} &lt;- AllIndexEntries]),
<a name="232"/>  232:                     
<a name="233"/>  233:                     %% Check: all policies in main table have corresponding index entries
<a name="234"/>  234:                     AllMainPolicies = ets:match_object(policy_store, {{TenantId, '_'}, '_'}),
<a name="235"/>  235:                     MainPolicyIds = lists:sort([PolicyId || {{_TenantId, PolicyId}, _Policy} &lt;- AllMainPolicies]),
<a name="236"/>  236:                     
<a name="237"/>  237:                     IndexComplete = MainPolicyIds =:= IndexPolicyIds,
<a name="238"/>  238:                     
<a name="239"/>  239:                     %% Check: bag index invariants
<a name="240"/>  240:                     %% 1. Each {TenantId, PolicyId} pair appears exactly once in index
<a name="241"/>  241:                     %% Bag allows multiple entries per key, but each {tenant_id, policy_id} pair should be unique
<a name="242"/>  242:                     IndexPairs = [{T, P} || {T, P} &lt;- AllIndexEntries],
<a name="243"/>  243:                     UniquePairs = lists:usort(IndexPairs),
<a name="244"/>  244:                     NoDuplicates = length(IndexPairs) =:= length(UniquePairs),
<a name="245"/>  245:                     
<a name="246"/>  246:                     %% 2. For each policy in main table, there's exactly one index entry
<a name="247"/>  247:                     OneToOne = length(MainPolicyIds) =:= length(IndexPolicyIds),
<a name="248"/>  248:                     
<a name="249"/>  249:                     %% 3. Bag index deletion uses delete_object (not delete)
<a name="250"/>  250:                     %% This ensures that only specific {tenant_id, policy_id} pairs are removed,
<a name="251"/>  251:                     %% not all entries for a tenant_id
<a name="252"/>  252:                     %% Verification: index should only contain pairs that exist in main table
<a name="253"/>  253:                     IndexPairsSet = sets:from_list(IndexPairs),
<a name="254"/>  254:                     MainPairsSet = sets:from_list([{TenantId, PolicyId} || {{_T, PolicyId}, _} &lt;- AllMainPolicies]),
<a name="255"/>  255:                     IndexMatchesMain = sets:is_equal(IndexPairsSet, MainPairsSet),
<a name="256"/>  256:                     
<a name="257"/>  257:                     %% All checks must pass
<a name="258"/>  258:                     IndexConsistent andalso IndexComplete andalso NoDuplicates andalso OneToOne andalso IndexMatchesMain
<a name="259"/>  259:                 end
<a name="260"/>  260:             ),
<a name="261"/>  261:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="262"/>  262:             case Result of
<a name="263"/>  263:                 true -&gt; 
<a name="264"/>  264:                     ok;
<a name="265"/>  265:                 false -&gt;
<a name="266"/>  266:                     ct:fail(&quot;Property failed&quot;);
<a name="267"/>  267:                 {false, CounterExample} -&gt;
<a name="268"/>  268:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="269"/>  269:                 Other -&gt;
<a name="270"/>  270:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="271"/>  271:             end
<a name="272"/>  272:     end.
<a name="273"/>  273: 
<a name="274"/>  274: <i>%% Property: Index deduplication after upsert -&gt; delete -&gt; upsert sequence</i>
<a name="275"/>  275: <i>%% Verifies that bag index table doesn't accumulate duplicates after delete/upsert cycles</i>
<a name="prop_index_deduplication-1"/><a name="276"/>  276: <b>prop_index_deduplication</b>(_Config) -&gt;
<a name="prop_index_deduplication-last_expr"/><a name="277"/>  277: <b>    case code:which</b>(proper) of
<a name="278"/>  278:         non_existing -&gt;
<a name="279"/>  279:             {skip, &quot;PropEr not available&quot;};
<a name="280"/>  280:         _ -&gt;
<a name="281"/>  281:             Prop = ?FORALL(
<a name="282"/>  282:                 {PolicyId, Policy},
<a name="283"/>  283:                 {policy_id(), policy()},
<a name="284"/>  284:                 begin
<a name="285"/>  285:                     TenantId = &lt;&lt;&quot;prop_dedup_tenant&quot;&gt;&gt;,
<a name="286"/>  286:                     
<a name="287"/>  287:                     %% Step 1: Upsert policy (creates index entry)
<a name="288"/>  288:                     ok = router_policy_store:upsert_policy(TenantId, Policy#policy{policy_id = PolicyId}),
<a name="289"/>  289:                     
<a name="290"/>  290:                     %% Verify initial state: exactly one index entry
<a name="291"/>  291:                     IndexTable = policy_store_index,
<a name="292"/>  292:                     InitialEntries = ets:match_object(IndexTable, {TenantId, PolicyId}),
<a name="293"/>  293:                     InitialCount = length(InitialEntries),
<a name="294"/>  294:                     
<a name="295"/>  295:                     %% Step 2: Delete policy (removes index entry via match_delete)
<a name="296"/>  296:                     ok = router_policy_store:delete_policy(TenantId, PolicyId),
<a name="297"/>  297:                     
<a name="298"/>  298:                     %% Verify deletion: no index entries (match_delete should remove all)
<a name="299"/>  299:                     %% Note: bag table allows duplicates, but match_delete removes all matching entries
<a name="300"/>  300:                     AfterDeleteEntries = ets:match_object(IndexTable, {TenantId, PolicyId}),
<a name="301"/>  301:                     AfterDeleteCount = length(AfterDeleteEntries),
<a name="302"/>  302:                     
<a name="303"/>  303:                     %% Also verify main table is empty
<a name="304"/>  304:                     AfterDeleteMain = ets:match_object(policy_store, {{TenantId, PolicyId}, '_'}),
<a name="305"/>  305:                     AfterDeleteMainCount = length(AfterDeleteMain),
<a name="306"/>  306:                     
<a name="307"/>  307:                     %% Step 3: Upsert same policy again (should create single index entry, not duplicate)
<a name="308"/>  308:                     ok = router_policy_store:upsert_policy(TenantId, Policy#policy{policy_id = PolicyId}),
<a name="309"/>  309:                     
<a name="310"/>  310:                     %% Verify final state: index should have exactly one entry for this {TenantId, PolicyId} pair
<a name="311"/>  311:                     FinalEntries = ets:match_object(IndexTable, {TenantId, PolicyId}),
<a name="312"/>  312:                     FinalCount = length(FinalEntries),
<a name="313"/>  313:                     
<a name="314"/>  314:                     %% Verify: main table has exactly one entry
<a name="315"/>  315:                     MainEntries = ets:match_object(policy_store, {{TenantId, PolicyId}, '_'}),
<a name="316"/>  316:                     MainCount = length(MainEntries),
<a name="317"/>  317:                     
<a name="318"/>  318:                     %% All checks: initial=1, after delete=0 (both index and main), final=1, main=1
<a name="319"/>  319:                     InitialCount =:= 1 andalso
<a name="320"/>  320:                     AfterDeleteCount =:= 0 andalso
<a name="321"/>  321:                     AfterDeleteMainCount =:= 0 andalso
<a name="322"/>  322:                     FinalCount =:= 1 andalso
<a name="323"/>  323:                     MainCount =:= 1
<a name="324"/>  324:                 end
<a name="325"/>  325:             ),
<a name="326"/>  326:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="327"/>  327:             case Result of
<a name="328"/>  328:                 true -&gt; 
<a name="329"/>  329:                     ok;
<a name="330"/>  330:                 false -&gt;
<a name="331"/>  331:                     ct:fail(&quot;Property failed&quot;);
<a name="332"/>  332:                 {false, CounterExample} -&gt;
<a name="333"/>  333:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="334"/>  334:                 Other -&gt;
<a name="335"/>  335:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="336"/>  336:             end
<a name="337"/>  337:     end.
<a name="338"/>  338: 
<a name="339"/>  339: <i>%% Generators</i>
<a name="340"/>  340: 
<a name="operation-0"/><a name="341"/>  341: <b>operation</b>() -&gt;
<a name="operation-last_expr"/><a name="342"/>  342: <b>    oneof</b>([
<a name="343"/>  343:         upsert_operation(),
<a name="344"/>  344:         delete_operation()
<a name="345"/>  345:     ]).
<a name="346"/>  346: 
<a name="upsert_operation-0"/><a name="347"/>  347: <b>upsert_operation</b>() -&gt;
<a name="upsert_operation-last_expr"/><a name="348"/>  348: <b>    ?LET</b>(
<a name="349"/>  349:         {PolicyId, Weights},
<a name="350"/>  350:         {policy_id(), weights()},
<a name="351"/>  351:         {upsert, #policy{
<a name="352"/>  352:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="353"/>  353:             policy_id = PolicyId,
<a name="354"/>  354:             weights = Weights,
<a name="355"/>  355:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="356"/>  356:             defaults = #{},
<a name="357"/>  357:             escalate_on = [],
<a name="358"/>  358:             fallback = undefined,
<a name="359"/>  359:             sticky = undefined,
<a name="360"/>  360:             metadata = #{}
<a name="361"/>  361:         }}
<a name="362"/>  362:     ).
<a name="363"/>  363: 
<a name="delete_operation-0"/><a name="364"/>  364: <b>delete_operation</b>() -&gt;
<a name="delete_operation-last_expr"/><a name="365"/>  365: <b>    ?LET</b>(
<a name="366"/>  366:         PolicyId,
<a name="367"/>  367:         policy_id(),
<a name="368"/>  368:         {delete, PolicyId}
<a name="369"/>  369:     ).
<a name="370"/>  370: 
<a name="policy-0"/><a name="371"/>  371: <b>policy</b>() -&gt;
<a name="policy-last_expr"/><a name="372"/>  372: <b>    ?LET</b>(
<a name="373"/>  373:         {PolicyId, Weights},
<a name="374"/>  374:         {policy_id(), weights()},
<a name="375"/>  375:         #policy{
<a name="376"/>  376:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="377"/>  377:             policy_id = PolicyId,
<a name="378"/>  378:             weights = Weights,
<a name="379"/>  379:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="380"/>  380:             defaults = #{},
<a name="381"/>  381:             escalate_on = [],
<a name="382"/>  382:             fallback = undefined,
<a name="383"/>  383:             sticky = undefined,
<a name="384"/>  384:             metadata = #{}
<a name="385"/>  385:         }
<a name="386"/>  386:     ).
<a name="387"/>  387: 
<a name="policy_id-0"/><a name="388"/>  388: <b>policy_id</b>() -&gt;
<a name="policy_id-last_expr"/><a name="389"/>  389: <b>    ?LET</b>(
<a name="390"/>  390:         N,
<a name="391"/>  391:         integer(1, 1000),
<a name="392"/>  392:         list_to_binary(&quot;policy_&quot; ++ integer_to_list(N))
<a name="393"/>  393:     ).
<a name="394"/>  394: 
<a name="weights-0"/><a name="395"/>  395: <b>weights</b>() -&gt;
<a name="weights-last_expr"/><a name="396"/>  396: <b>    ?LET</b>(
<a name="397"/>  397:         Providers,
<a name="398"/>  398:         list({provider_id(), weight()}),
<a name="399"/>  399:         maps:from_list(Providers)
<a name="400"/>  400:     ).
<a name="401"/>  401: 
<a name="provider_id-0"/><a name="402"/>  402: <b>provider_id</b>() -&gt;
<a name="provider_id-last_expr"/><a name="403"/>  403: <b>    oneof</b>([&lt;&lt;&quot;openai&quot;&gt;&gt;, &lt;&lt;&quot;anthropic&quot;&gt;&gt;, &lt;&lt;&quot;cohere&quot;&gt;&gt;]).
<a name="404"/>  404: 
<a name="weight-0"/><a name="405"/>  405: <b>weight</b>() -&gt;
<a name="weight-last_expr"/><a name="406"/>  406: <b>    ?LET</b>(
<a name="407"/>  407:         W,
<a name="408"/>  408:         real(),
<a name="409"/>  409:         max(0.0, min(1.0, abs(W)))
<a name="410"/>  410:     ).
<a name="411"/>  411: 
<a name="412"/>  412: <i>%% Helpers</i>
<a name="413"/>  413: 
<a name="execute_operation-2"/><a name="414"/>  414: <b>execute_operation</b>(TenantId, {upsert, Policy}) -&gt;
<a name="415"/>  415:     router_policy_store:upsert_policy(TenantId, Policy);
<a name="416"/>  416: <b>execute_operation</b>(TenantId, {delete, PolicyId}) -&gt;
<a name="execute_operation-last_expr"/><a name="417"/>  417: <b>    router_policy_store:delete_policy</b>(TenantId, PolicyId).
<a name="418"/>  418: 
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
