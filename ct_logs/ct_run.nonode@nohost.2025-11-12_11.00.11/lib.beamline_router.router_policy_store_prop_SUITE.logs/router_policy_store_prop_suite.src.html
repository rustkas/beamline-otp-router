<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/home/rustkas/aigroup/apps/otp/router/_build/test/lib/beamline_router/test/router_policy_store_prop_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%% @doc Property-based tests for router_policy_store</i>
<a name="2"/>    2: <i>%% Uses PropEr for randomized sequence of operations to detect race conditions</i>
<a name="3"/>    3: <b>-module</b>(router_policy_store_prop_SUITE).
<a name="4"/>    4: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="5"/>    5: 
<a name="6"/>    6: <i>%% Always include proper.hrl in test profile (PropEr is available in test profile)</i>
<a name="7"/>    7: <i>%% Runtime check for PropEr availability is done in prop_* functions</i>
<a name="8"/>    8: <b>-include_lib</b>(&quot;proper/include/proper.hrl&quot;).
<a name="9"/>    9: 
<a name="10"/>   10: <b>-compile</b>(export_all).
<a name="11"/>   11: 
<a name="12"/>   12: <b>-export</b>([all/0, init_per_suite/1, end_per_suite/1]).
<a name="13"/>   13: 
<a name="14"/>   14: <b>-include</b>(&quot;beamline_router.hrl&quot;).
<a name="15"/>   15: 
<a name="all-0"/><a name="16"/>   16: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="17"/>   17: <b>    case code:which</b>(proper) of
<a name="18"/>   18:         non_existing -&gt; [
<a name="19"/>   19:             prop_concurrent_operations_skip,
<a name="20"/>   20:             prop_upsert_delete_consistency_skip,
<a name="21"/>   21:             prop_list_policies_ordering_skip,
<a name="22"/>   22:             prop_index_consistency_skip
<a name="23"/>   23:         ];
<a name="24"/>   24:         _ -&gt; [
<a name="25"/>   25:             prop_concurrent_operations,
<a name="26"/>   26:             prop_upsert_delete_consistency,
<a name="27"/>   27:             prop_list_policies_ordering,
<a name="28"/>   28:             prop_index_consistency
<a name="29"/>   29:         ]
<a name="30"/>   30:     end.
<a name="31"/>   31: 
<a name="init_per_suite-1"/><a name="32"/>   32: <b>init_per_suite</b>(Config) -&gt;
<a name="33"/>   33:     %% Start application with ephemeral port
<a name="34"/>   34:     _ = application:load(beamline_router),
<a name="35"/>   35:     ok = application:set_env(beamline_router, grpc_port, 0),
<a name="36"/>   36:     %% Disable heir/transfer logic for faster test execution
<a name="37"/>   37:     ok = application:set_env(beamline_router, disable_heir, true),
<a name="38"/>   38:     ok = application:set_env(beamline_router, grpc_enabled, false),
<a name="39"/>   39:     ok = application:set_env(beamline_router, nats_mode, mock),
<a name="init_per_suite-last_expr"/><a name="40"/>   40: <b>    case application:ensure_all_started</b>(beamline_router) of
<a name="41"/>   41:         {ok, _} -&gt;
<a name="42"/>   42:             Config;
<a name="43"/>   43:         Error -&gt;
<a name="44"/>   44:             ct:fail(&quot;Failed to start beamline_router: ~p&quot;, [Error])
<a name="45"/>   45:     end.
<a name="46"/>   46: 
<a name="end_per_suite-1"/><a name="47"/>   47: <b>end_per_suite</b>(_Config) -&gt;
<a name="48"/>   48:     application:stop(beamline_router),
<a name="end_per_suite-last_expr"/><a name="49"/>   49:     ok.
<a name="50"/>   50: 
<a name="51"/>   51: <i>%% Skip tests if PropEr not available</i>
<a name="prop_concurrent_operations_skip-1"/><a name="52"/>   52: <b>prop_concurrent_operations_skip</b>(_Config) -&gt;
<a name="prop_concurrent_operations_skip-last_expr"/><a name="53"/>   53:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_upsert_delete_consistency_skip-1"/><a name="54"/>   54: <b>prop_upsert_delete_consistency_skip</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency_skip-last_expr"/><a name="55"/>   55:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_list_policies_ordering_skip-1"/><a name="56"/>   56: <b>prop_list_policies_ordering_skip</b>(_Config) -&gt;
<a name="prop_list_policies_ordering_skip-last_expr"/><a name="57"/>   57:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_index_consistency_skip-1"/><a name="58"/>   58: <b>prop_index_consistency_skip</b>(_Config) -&gt;
<a name="prop_index_consistency_skip-last_expr"/><a name="59"/>   59:     {skip, &quot;PropEr not available&quot;}.
<a name="60"/>   60: 
<a name="61"/>   61: <i>%% Property: Concurrent operations maintain consistency</i>
<a name="prop_concurrent_operations-1"/><a name="62"/>   62: <b>prop_concurrent_operations</b>(_Config) -&gt;
<a name="prop_concurrent_operations-last_expr"/><a name="63"/>   63: <b>    case code:which</b>(proper) of
<a name="64"/>   64:         non_existing -&gt;
<a name="65"/>   65:             {skip, &quot;PropEr not available&quot;};
<a name="66"/>   66:         _ -&gt;
<a name="67"/>   67:             Prop = ?FORALL(
<a name="68"/>   68:                 Operations,
<a name="69"/>   69:                 list(operation()),
<a name="70"/>   70:                 begin
<a name="71"/>   71:                     TenantId = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="72"/>   72:                     %% Execute operations sequentially (gen_server serializes)
<a name="73"/>   73:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="74"/>   74:                     
<a name="75"/>   75:                     %% Verify final state is consistent
<a name="76"/>   76:                     {ok, FinalPolicies} = router_policy_store:list_policies(TenantId),
<a name="77"/>   77:                     
<a name="78"/>   78:                     %% Check: all policies in list should be valid
<a name="79"/>   79:                     AllValid = lists:all(fun(P) -&gt;
<a name="80"/>   80:                         is_record(P, policy) andalso
<a name="81"/>   81:                         P#policy.tenant_id =:= TenantId
<a name="82"/>   82:                     end, FinalPolicies),
<a name="83"/>   83:                     
<a name="84"/>   84:                     %% Check: no duplicate policy_ids
<a name="85"/>   85:                     PolicyIds = [P#policy.policy_id || P &lt;- FinalPolicies],
<a name="86"/>   86:                     NoDuplicates = length(PolicyIds) =:= length(lists:usort(PolicyIds)),
<a name="87"/>   87:                     
<a name="88"/>   88:                     AllValid andalso NoDuplicates
<a name="89"/>   89:                 end
<a name="90"/>   90:             ),
<a name="91"/>   91:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="92"/>   92:             case Result of
<a name="93"/>   93:                 true -&gt; 
<a name="94"/>   94:                     ok;
<a name="95"/>   95:                 false -&gt;
<a name="96"/>   96:                     ct:fail(&quot;Property failed&quot;);
<a name="97"/>   97:                 {false, CounterExample} -&gt;
<a name="98"/>   98:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="99"/>   99:                 Other -&gt;
<a name="100"/>  100:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="101"/>  101:             end
<a name="102"/>  102:     end.
<a name="103"/>  103: 
<a name="104"/>  104: <i>%% Property: Upsert and delete maintain consistency</i>
<a name="prop_upsert_delete_consistency-1"/><a name="105"/>  105: <b>prop_upsert_delete_consistency</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency-last_expr"/><a name="106"/>  106: <b>    case code:which</b>(proper) of
<a name="107"/>  107:         non_existing -&gt;
<a name="108"/>  108:             {skip, &quot;PropEr not available&quot;};
<a name="109"/>  109:         _ -&gt;
<a name="110"/>  110:             Prop = ?FORALL(
<a name="111"/>  111:                 {Upserts, Deletes},
<a name="112"/>  112:                 {list(upsert_operation()), list(delete_operation())},
<a name="113"/>  113:                 begin
<a name="114"/>  114:                     TenantId = &lt;&lt;&quot;prop_consistency_tenant&quot;&gt;&gt;,
<a name="115"/>  115:                     
<a name="116"/>  116:                     %% Execute all upserts first
<a name="117"/>  117:                     [execute_operation(TenantId, Op) || Op &lt;- Upserts],
<a name="118"/>  118:                     
<a name="119"/>  119:                     %% Get policy IDs from upserts
<a name="120"/>  120:                     UpsertedIds = [Policy#policy.policy_id || {upsert, Policy} &lt;- Upserts],
<a name="121"/>  121:                     
<a name="122"/>  122:                     %% Execute all deletes
<a name="123"/>  123:                     [execute_operation(TenantId, Op) || Op &lt;- Deletes],
<a name="124"/>  124:                     
<a name="125"/>  125:                     %% Get deleted policy IDs
<a name="126"/>  126:                     DeletedIds = [PolicyId || {delete, PolicyId} &lt;- Deletes],
<a name="127"/>  127:                     
<a name="128"/>  128:                     %% Get final state
<a name="129"/>  129:                     {ok, Policies} = router_policy_store:list_policies(TenantId),
<a name="130"/>  130:                     FinalPolicyIds = [P#policy.policy_id || P &lt;- Policies],
<a name="131"/>  131:                     
<a name="132"/>  132:                     %% Check: policies that were deleted and NOT re-upserted should not be in final list
<a name="133"/>  133:                     %% A policy is truly deleted if it was deleted AND not re-upserted after deletion
<a name="134"/>  134:                     TrulyDeleted = [Id || Id &lt;- DeletedIds, not lists:member(Id, UpsertedIds)],
<a name="135"/>  135:                     
<a name="136"/>  136:                     %% Verify: truly deleted policies should not be in final list
<a name="137"/>  137:                     lists:all(fun(DeletedId) -&gt;
<a name="138"/>  138:                         not lists:member(DeletedId, FinalPolicyIds)
<a name="139"/>  139:                     end, TrulyDeleted)
<a name="140"/>  140:                 end
<a name="141"/>  141:             ),
<a name="142"/>  142:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="143"/>  143:             case Result of
<a name="144"/>  144:                 true -&gt; 
<a name="145"/>  145:                     ok;
<a name="146"/>  146:                 false -&gt;
<a name="147"/>  147:                     ct:fail(&quot;Property failed&quot;);
<a name="148"/>  148:                 {false, CounterExample} -&gt;
<a name="149"/>  149:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="150"/>  150:                 Other -&gt;
<a name="151"/>  151:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="152"/>  152:             end
<a name="153"/>  153:     end.
<a name="154"/>  154: 
<a name="155"/>  155: <i>%% Property: list_policies always returns sorted results</i>
<a name="prop_list_policies_ordering-1"/><a name="156"/>  156: <b>prop_list_policies_ordering</b>(_Config) -&gt;
<a name="prop_list_policies_ordering-last_expr"/><a name="157"/>  157: <b>    case code:which</b>(proper) of
<a name="158"/>  158:         non_existing -&gt;
<a name="159"/>  159:             {skip, &quot;PropEr not available&quot;};
<a name="160"/>  160:         _ -&gt;
<a name="161"/>  161:             Prop = ?FORALL(
<a name="162"/>  162:                 Policies,
<a name="163"/>  163:                 list(policy()),
<a name="164"/>  164:                 begin
<a name="165"/>  165:                     TenantId = &lt;&lt;&quot;prop_ordering_tenant&quot;&gt;&gt;,
<a name="166"/>  166:                     
<a name="167"/>  167:                     %% Clear existing policies
<a name="168"/>  168:                     {ok, Existing} = router_policy_store:list_policies(TenantId),
<a name="169"/>  169:                     [router_policy_store:delete_policy(TenantId, P#policy.policy_id) || P &lt;- Existing],
<a name="170"/>  170:                     
<a name="171"/>  171:                     %% Insert all policies
<a name="172"/>  172:                     [router_policy_store:upsert_policy(TenantId, P) || P &lt;- Policies],
<a name="173"/>  173:                     
<a name="174"/>  174:                     %% Get list
<a name="175"/>  175:                     {ok, Listed} = router_policy_store:list_policies(TenantId),
<a name="176"/>  176:                     
<a name="177"/>  177:                     %% Check: results are sorted by policy_id (lexicographic binary order)
<a name="178"/>  178:                     PolicyIds = [P#policy.policy_id || P &lt;- Listed],
<a name="179"/>  179:                     %% Use Erlang term ordering (&lt;) to match implementation
<a name="180"/>  180:                     Sorted = lists:sort(PolicyIds),
<a name="181"/>  181:                     
<a name="182"/>  182:                     PolicyIds =:= Sorted
<a name="183"/>  183:                 end
<a name="184"/>  184:             ),
<a name="185"/>  185:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="186"/>  186:             case Result of
<a name="187"/>  187:                 true -&gt; 
<a name="188"/>  188:                     ok;
<a name="189"/>  189:                 false -&gt;
<a name="190"/>  190:                     ct:fail(&quot;Property failed&quot;);
<a name="191"/>  191:                 {false, CounterExample} -&gt;
<a name="192"/>  192:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="193"/>  193:                 Other -&gt;
<a name="194"/>  194:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="195"/>  195:             end
<a name="196"/>  196:     end.
<a name="197"/>  197: 
<a name="198"/>  198: <i>%% Property: Secondary index maintains consistency with main table</i>
<a name="prop_index_consistency-1"/><a name="199"/>  199: <b>prop_index_consistency</b>(_Config) -&gt;
<a name="prop_index_consistency-last_expr"/><a name="200"/>  200: <b>    case code:which</b>(proper) of
<a name="201"/>  201:         non_existing -&gt;
<a name="202"/>  202:             {skip, &quot;PropEr not available&quot;};
<a name="203"/>  203:         _ -&gt;
<a name="204"/>  204:             Prop = ?FORALL(
<a name="205"/>  205:                 Operations,
<a name="206"/>  206:                 list(operation()),
<a name="207"/>  207:                 begin
<a name="208"/>  208:                     TenantId = &lt;&lt;&quot;prop_index_tenant&quot;&gt;&gt;,
<a name="209"/>  209:                     
<a name="210"/>  210:                     %% Execute operations
<a name="211"/>  211:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="212"/>  212:                     
<a name="213"/>  213:                     %% Get policies via list_policies (uses index)
<a name="214"/>  214:                     {ok, IndexedPolicies} = router_policy_store:list_policies(TenantId),
<a name="215"/>  215:                     IndexedIds = lists:sort([P#policy.policy_id || P &lt;- IndexedPolicies]),
<a name="216"/>  216:                     
<a name="217"/>  217:                     %% Get policies via direct lookup (bypasses index)
<a name="218"/>  218:                     AllKeys = ets:match(policy_store, {{TenantId, '$1'}, '_'}),
<a name="219"/>  219:                     DirectIds = lists:sort([Id || [Id] &lt;- AllKeys]),
<a name="220"/>  220:                     
<a name="221"/>  221:                     %% Check: index and direct lookup should match
<a name="222"/>  222:                     IndexConsistent = IndexedIds =:= DirectIds,
<a name="223"/>  223:                     
<a name="224"/>  224:                     %% Check: for each {TenantId, PolicyId} in main table, there's exactly one entry in index
<a name="225"/>  225:                     IndexTable = policy_store_index,
<a name="226"/>  226:                     AllIndexEntries = ets:match_object(IndexTable, {TenantId, '_'}),
<a name="227"/>  227:                     IndexPolicyIds = lists:sort([PolicyId || {_TenantId, PolicyId} &lt;- AllIndexEntries]),
<a name="228"/>  228:                     
<a name="229"/>  229:                     %% Check: all policies in main table have corresponding index entries
<a name="230"/>  230:                     AllMainPolicies = ets:match_object(policy_store, {{TenantId, '_'}, '_'}),
<a name="231"/>  231:                     MainPolicyIds = lists:sort([PolicyId || {{_TenantId, PolicyId}, _Policy} &lt;- AllMainPolicies]),
<a name="232"/>  232:                     
<a name="233"/>  233:                     IndexComplete = MainPolicyIds =:= IndexPolicyIds,
<a name="234"/>  234:                     
<a name="235"/>  235:                     %% Check: bag index invariants
<a name="236"/>  236:                     %% 1. Each {TenantId, PolicyId} pair appears exactly once in index
<a name="237"/>  237:                     %% Bag allows multiple entries per key, but each {tenant_id, policy_id} pair should be unique
<a name="238"/>  238:                     IndexPairs = [{T, P} || {T, P} &lt;- AllIndexEntries],
<a name="239"/>  239:                     UniquePairs = lists:usort(IndexPairs),
<a name="240"/>  240:                     NoDuplicates = length(IndexPairs) =:= length(UniquePairs),
<a name="241"/>  241:                     
<a name="242"/>  242:                     %% 2. For each policy in main table, there's exactly one index entry
<a name="243"/>  243:                     OneToOne = length(MainPolicyIds) =:= length(IndexPolicyIds),
<a name="244"/>  244:                     
<a name="245"/>  245:                     %% 3. Bag index deletion uses delete_object (not delete)
<a name="246"/>  246:                     %% This ensures that only specific {tenant_id, policy_id} pairs are removed,
<a name="247"/>  247:                     %% not all entries for a tenant_id
<a name="248"/>  248:                     %% Verification: index should only contain pairs that exist in main table
<a name="249"/>  249:                     IndexPairsSet = sets:from_list(IndexPairs),
<a name="250"/>  250:                     MainPairsSet = sets:from_list([{TenantId, PolicyId} || {{_T, PolicyId}, _} &lt;- AllMainPolicies]),
<a name="251"/>  251:                     IndexMatchesMain = sets:is_equal(IndexPairsSet, MainPairsSet),
<a name="252"/>  252:                     
<a name="253"/>  253:                     %% All checks must pass
<a name="254"/>  254:                     IndexConsistent andalso IndexComplete andalso NoDuplicates andalso OneToOne andalso IndexMatchesMain
<a name="255"/>  255:                 end
<a name="256"/>  256:             ),
<a name="257"/>  257:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="258"/>  258:             case Result of
<a name="259"/>  259:                 true -&gt; 
<a name="260"/>  260:                     ok;
<a name="261"/>  261:                 false -&gt;
<a name="262"/>  262:                     ct:fail(&quot;Property failed&quot;);
<a name="263"/>  263:                 {false, CounterExample} -&gt;
<a name="264"/>  264:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="265"/>  265:                 Other -&gt;
<a name="266"/>  266:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="267"/>  267:             end
<a name="268"/>  268:     end.
<a name="269"/>  269: 
<a name="270"/>  270: <i>%% Generators</i>
<a name="271"/>  271: 
<a name="operation-0"/><a name="272"/>  272: <b>operation</b>() -&gt;
<a name="operation-last_expr"/><a name="273"/>  273: <b>    oneof</b>([
<a name="274"/>  274:         upsert_operation(),
<a name="275"/>  275:         delete_operation()
<a name="276"/>  276:     ]).
<a name="277"/>  277: 
<a name="upsert_operation-0"/><a name="278"/>  278: <b>upsert_operation</b>() -&gt;
<a name="upsert_operation-last_expr"/><a name="279"/>  279: <b>    ?LET</b>(
<a name="280"/>  280:         {PolicyId, Weights},
<a name="281"/>  281:         {policy_id(), weights()},
<a name="282"/>  282:         {upsert, #policy{
<a name="283"/>  283:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="284"/>  284:             policy_id = PolicyId,
<a name="285"/>  285:             weights = Weights,
<a name="286"/>  286:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="287"/>  287:             defaults = #{},
<a name="288"/>  288:             escalate_on = [],
<a name="289"/>  289:             fallback = undefined,
<a name="290"/>  290:             sticky = undefined,
<a name="291"/>  291:             metadata = #{}
<a name="292"/>  292:         }}
<a name="293"/>  293:     ).
<a name="294"/>  294: 
<a name="delete_operation-0"/><a name="295"/>  295: <b>delete_operation</b>() -&gt;
<a name="delete_operation-last_expr"/><a name="296"/>  296: <b>    ?LET</b>(
<a name="297"/>  297:         PolicyId,
<a name="298"/>  298:         policy_id(),
<a name="299"/>  299:         {delete, PolicyId}
<a name="300"/>  300:     ).
<a name="301"/>  301: 
<a name="policy-0"/><a name="302"/>  302: <b>policy</b>() -&gt;
<a name="policy-last_expr"/><a name="303"/>  303: <b>    ?LET</b>(
<a name="304"/>  304:         {PolicyId, Weights},
<a name="305"/>  305:         {policy_id(), weights()},
<a name="306"/>  306:         #policy{
<a name="307"/>  307:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="308"/>  308:             policy_id = PolicyId,
<a name="309"/>  309:             weights = Weights,
<a name="310"/>  310:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="311"/>  311:             defaults = #{},
<a name="312"/>  312:             escalate_on = [],
<a name="313"/>  313:             fallback = undefined,
<a name="314"/>  314:             sticky = undefined,
<a name="315"/>  315:             metadata = #{}
<a name="316"/>  316:         }
<a name="317"/>  317:     ).
<a name="318"/>  318: 
<a name="policy_id-0"/><a name="319"/>  319: <b>policy_id</b>() -&gt;
<a name="policy_id-last_expr"/><a name="320"/>  320: <b>    ?LET</b>(
<a name="321"/>  321:         N,
<a name="322"/>  322:         integer(1, 1000),
<a name="323"/>  323:         list_to_binary(&quot;policy_&quot; ++ integer_to_list(N))
<a name="324"/>  324:     ).
<a name="325"/>  325: 
<a name="weights-0"/><a name="326"/>  326: <b>weights</b>() -&gt;
<a name="weights-last_expr"/><a name="327"/>  327: <b>    ?LET</b>(
<a name="328"/>  328:         Providers,
<a name="329"/>  329:         list({provider_id(), weight()}),
<a name="330"/>  330:         maps:from_list(Providers)
<a name="331"/>  331:     ).
<a name="332"/>  332: 
<a name="provider_id-0"/><a name="333"/>  333: <b>provider_id</b>() -&gt;
<a name="provider_id-last_expr"/><a name="334"/>  334: <b>    oneof</b>([&lt;&lt;&quot;openai&quot;&gt;&gt;, &lt;&lt;&quot;anthropic&quot;&gt;&gt;, &lt;&lt;&quot;cohere&quot;&gt;&gt;]).
<a name="335"/>  335: 
<a name="weight-0"/><a name="336"/>  336: <b>weight</b>() -&gt;
<a name="weight-last_expr"/><a name="337"/>  337: <b>    ?LET</b>(
<a name="338"/>  338:         W,
<a name="339"/>  339:         real(),
<a name="340"/>  340:         max(0.0, min(1.0, abs(W)))
<a name="341"/>  341:     ).
<a name="342"/>  342: 
<a name="343"/>  343: <i>%% Helpers</i>
<a name="344"/>  344: 
<a name="execute_operation-2"/><a name="345"/>  345: <b>execute_operation</b>(TenantId, {upsert, Policy}) -&gt;
<a name="346"/>  346:     router_policy_store:upsert_policy(TenantId, Policy);
<a name="347"/>  347: <b>execute_operation</b>(TenantId, {delete, PolicyId}) -&gt;
<a name="execute_operation-last_expr"/><a name="348"/>  348: <b>    router_policy_store:delete_policy</b>(TenantId, PolicyId).
<a name="349"/>  349: 
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
