<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/home/rustkas/aigroup/apps/otp/router/_build/test/lib/beamline_router/test/router_policy_store_prop_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%% @doc Property-based tests for router_policy_store</i>
<a name="2"/>    2: <i>%% Uses PropEr for randomized sequence of operations to detect race conditions</i>
<a name="3"/>    3: <b>-module</b>(router_policy_store_prop_SUITE).
<a name="4"/>    4: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="5"/>    5: 
<a name="6"/>    6: <i>%% Check if PropEr is available</i>
<a name="7"/>    7: <b>-ifdef</b>(TEST).
<a name="8"/>    8: <b>-define</b>(HAVE_PROPER, code:which(proper) =/= non_existing).
<a name="9"/>    9: -else.
<a name="10"/>   10: <b>-define</b>(HAVE_PROPER, false).
<a name="11"/>   11: -endif.
<a name="12"/>   12: 
<a name="13"/>   13: <b>-ifdef</b>(HAVE_PROPER).
<a name="14"/>   14: <b>-include_lib</b>(&quot;proper/include/proper.hrl&quot;).
<a name="15"/>   15: -endif.
<a name="16"/>   16: 
<a name="17"/>   17: <b>-compile</b>(export_all).
<a name="18"/>   18: 
<a name="19"/>   19: <b>-export</b>([all/0, init_per_suite/1, end_per_suite/1]).
<a name="20"/>   20: 
<a name="21"/>   21: <b>-include</b>(&quot;beamline_router.hrl&quot;).
<a name="22"/>   22: 
<a name="all-0"/><a name="23"/>   23: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="24"/>   24:     [
<a name="25"/>   25:         prop_concurrent_operations,
<a name="26"/>   26:         prop_upsert_delete_consistency,
<a name="27"/>   27:         prop_list_policies_ordering,
<a name="28"/>   28:         prop_index_consistency
<a name="29"/>   29:     ].
<a name="30"/>   30: 
<a name="init_per_suite-1"/><a name="31"/>   31: <b>init_per_suite</b>(Config) -&gt;
<a name="32"/>   32:     %% Start application with ephemeral port
<a name="33"/>   33:     _ = application:load(beamline_router),
<a name="34"/>   34:     ok = application:set_env(beamline_router, grpc_port, 0),
<a name="35"/>   35:     %% Disable heir/transfer logic for faster test execution
<a name="36"/>   36:     ok = application:set_env(beamline_router, disable_heir, true),
<a name="37"/>   37:     ok = application:set_env(beamline_router, grpc_enabled, false),
<a name="38"/>   38:     ok = application:set_env(beamline_router, nats_mode, mock),
<a name="init_per_suite-last_expr"/><a name="39"/>   39: <b>    case application:ensure_all_started</b>(beamline_router) of
<a name="40"/>   40:         {ok, _} -&gt;
<a name="41"/>   41:             Config;
<a name="42"/>   42:         Error -&gt;
<a name="43"/>   43:             ct:fail(&quot;Failed to start beamline_router: ~p&quot;, [Error])
<a name="44"/>   44:     end.
<a name="45"/>   45: 
<a name="end_per_suite-1"/><a name="46"/>   46: <b>end_per_suite</b>(_Config) -&gt;
<a name="47"/>   47:     application:stop(beamline_router),
<a name="end_per_suite-last_expr"/><a name="48"/>   48:     ok.
<a name="49"/>   49: 
<a name="50"/>   50: <i>%% Property: Concurrent operations maintain consistency</i>
<a name="prop_concurrent_operations-1"/><a name="51"/>   51: <b>prop_concurrent_operations</b>(_Config) -&gt;
<a name="prop_concurrent_operations-last_expr"/><a name="52"/>   52:     case ?HAVE_PROPER of
<a name="53"/>   53:         false -&gt;
<a name="54"/>   54:             {skip, &quot;PropEr not available&quot;};
<a name="55"/>   55:         true -&gt;
<a name="56"/>   56:             Prop = ?FORALL(
<a name="57"/>   57:                 Operations,
<a name="58"/>   58:                 list(operation()),
<a name="59"/>   59:                 begin
<a name="60"/>   60:                     TenantId = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="61"/>   61:                     %% Execute operations sequentially (gen_server serializes)
<a name="62"/>   62:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="63"/>   63:                     
<a name="64"/>   64:                     %% Verify final state is consistent
<a name="65"/>   65:                     {ok, FinalPolicies} = router_policy_store:list_policies(TenantId),
<a name="66"/>   66:                     
<a name="67"/>   67:                     %% Check: all policies in list should be valid
<a name="68"/>   68:                     AllValid = lists:all(fun(P) -&gt;
<a name="69"/>   69:                         is_record(P, policy) andalso
<a name="70"/>   70:                         P#policy.tenant_id =:= TenantId
<a name="71"/>   71:                     end, FinalPolicies),
<a name="72"/>   72:                     
<a name="73"/>   73:                     %% Check: no duplicate policy_ids
<a name="74"/>   74:                     PolicyIds = [P#policy.policy_id || P &lt;- FinalPolicies],
<a name="75"/>   75:                     NoDuplicates = length(PolicyIds) =:= length(lists:usort(PolicyIds)),
<a name="76"/>   76:                     
<a name="77"/>   77:                     AllValid andalso NoDuplicates
<a name="78"/>   78:                 end
<a name="79"/>   79:             ),
<a name="80"/>   80:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="81"/>   81:             case Result of
<a name="82"/>   82:                 true -&gt; 
<a name="83"/>   83:                     ok;
<a name="84"/>   84:                 false -&gt;
<a name="85"/>   85:                     ct:fail(&quot;Property failed&quot;);
<a name="86"/>   86:                 {false, CounterExample} -&gt;
<a name="87"/>   87:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="88"/>   88:                 Other -&gt;
<a name="89"/>   89:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="90"/>   90:             end
<a name="91"/>   91:     end.
<a name="92"/>   92: 
<a name="93"/>   93: <i>%% Property: Upsert and delete maintain consistency</i>
<a name="prop_upsert_delete_consistency-1"/><a name="94"/>   94: <b>prop_upsert_delete_consistency</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency-last_expr"/><a name="95"/>   95:     case ?HAVE_PROPER of
<a name="96"/>   96:         false -&gt;
<a name="97"/>   97:             {skip, &quot;PropEr not available&quot;};
<a name="98"/>   98:         true -&gt;
<a name="99"/>   99:             Prop = ?FORALL(
<a name="100"/>  100:                 {Upserts, Deletes},
<a name="101"/>  101:                 {list(upsert_operation()), list(delete_operation())},
<a name="102"/>  102:                 begin
<a name="103"/>  103:                     TenantId = &lt;&lt;&quot;prop_consistency_tenant&quot;&gt;&gt;,
<a name="104"/>  104:                     
<a name="105"/>  105:                     %% Execute all upserts first
<a name="106"/>  106:                     [execute_operation(TenantId, Op) || Op &lt;- Upserts],
<a name="107"/>  107:                     
<a name="108"/>  108:                     %% Get policy IDs from upserts
<a name="109"/>  109:                     UpsertedIds = [Policy#policy.policy_id || {upsert, Policy} &lt;- Upserts],
<a name="110"/>  110:                     
<a name="111"/>  111:                     %% Execute all deletes
<a name="112"/>  112:                     [execute_operation(TenantId, Op) || Op &lt;- Deletes],
<a name="113"/>  113:                     
<a name="114"/>  114:                     %% Get deleted policy IDs
<a name="115"/>  115:                     DeletedIds = [PolicyId || {delete, PolicyId} &lt;- Deletes],
<a name="116"/>  116:                     
<a name="117"/>  117:                     %% Get final state
<a name="118"/>  118:                     {ok, Policies} = router_policy_store:list_policies(TenantId),
<a name="119"/>  119:                     FinalPolicyIds = [P#policy.policy_id || P &lt;- Policies],
<a name="120"/>  120:                     
<a name="121"/>  121:                     %% Check: policies that were deleted and NOT re-upserted should not be in final list
<a name="122"/>  122:                     %% A policy is truly deleted if it was deleted AND not re-upserted after deletion
<a name="123"/>  123:                     TrulyDeleted = [Id || Id &lt;- DeletedIds, not lists:member(Id, UpsertedIds)],
<a name="124"/>  124:                     
<a name="125"/>  125:                     %% Verify: truly deleted policies should not be in final list
<a name="126"/>  126:                     lists:all(fun(DeletedId) -&gt;
<a name="127"/>  127:                         not lists:member(DeletedId, FinalPolicyIds)
<a name="128"/>  128:                     end, TrulyDeleted)
<a name="129"/>  129:                 end
<a name="130"/>  130:             ),
<a name="131"/>  131:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="132"/>  132:             case Result of
<a name="133"/>  133:                 true -&gt; 
<a name="134"/>  134:                     ok;
<a name="135"/>  135:                 false -&gt;
<a name="136"/>  136:                     ct:fail(&quot;Property failed&quot;);
<a name="137"/>  137:                 {false, CounterExample} -&gt;
<a name="138"/>  138:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="139"/>  139:                 Other -&gt;
<a name="140"/>  140:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="141"/>  141:             end
<a name="142"/>  142:     end.
<a name="143"/>  143: 
<a name="144"/>  144: <i>%% Property: list_policies always returns sorted results</i>
<a name="prop_list_policies_ordering-1"/><a name="145"/>  145: <b>prop_list_policies_ordering</b>(_Config) -&gt;
<a name="prop_list_policies_ordering-last_expr"/><a name="146"/>  146:     case ?HAVE_PROPER of
<a name="147"/>  147:         false -&gt;
<a name="148"/>  148:             {skip, &quot;PropEr not available&quot;};
<a name="149"/>  149:         true -&gt;
<a name="150"/>  150:             Prop = ?FORALL(
<a name="151"/>  151:                 Policies,
<a name="152"/>  152:                 list(policy()),
<a name="153"/>  153:                 begin
<a name="154"/>  154:                     TenantId = &lt;&lt;&quot;prop_ordering_tenant&quot;&gt;&gt;,
<a name="155"/>  155:                     
<a name="156"/>  156:                     %% Clear existing policies
<a name="157"/>  157:                     {ok, Existing} = router_policy_store:list_policies(TenantId),
<a name="158"/>  158:                     [router_policy_store:delete_policy(TenantId, P#policy.policy_id) || P &lt;- Existing],
<a name="159"/>  159:                     
<a name="160"/>  160:                     %% Insert all policies
<a name="161"/>  161:                     [router_policy_store:upsert_policy(TenantId, P) || P &lt;- Policies],
<a name="162"/>  162:                     
<a name="163"/>  163:                     %% Get list
<a name="164"/>  164:                     {ok, Listed} = router_policy_store:list_policies(TenantId),
<a name="165"/>  165:                     
<a name="166"/>  166:                     %% Check: results are sorted by policy_id (lexicographic binary order)
<a name="167"/>  167:                     PolicyIds = [P#policy.policy_id || P &lt;- Listed],
<a name="168"/>  168:                     %% Use Erlang term ordering (&lt;) to match implementation
<a name="169"/>  169:                     Sorted = lists:sort(PolicyIds),
<a name="170"/>  170:                     
<a name="171"/>  171:                     PolicyIds =:= Sorted
<a name="172"/>  172:                 end
<a name="173"/>  173:             ),
<a name="174"/>  174:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="175"/>  175:             case Result of
<a name="176"/>  176:                 true -&gt; 
<a name="177"/>  177:                     ok;
<a name="178"/>  178:                 false -&gt;
<a name="179"/>  179:                     ct:fail(&quot;Property failed&quot;);
<a name="180"/>  180:                 {false, CounterExample} -&gt;
<a name="181"/>  181:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="182"/>  182:                 Other -&gt;
<a name="183"/>  183:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="184"/>  184:             end
<a name="185"/>  185:     end.
<a name="186"/>  186: 
<a name="187"/>  187: <i>%% Property: Secondary index maintains consistency with main table</i>
<a name="prop_index_consistency-1"/><a name="188"/>  188: <b>prop_index_consistency</b>(_Config) -&gt;
<a name="prop_index_consistency-last_expr"/><a name="189"/>  189:     case ?HAVE_PROPER of
<a name="190"/>  190:         false -&gt;
<a name="191"/>  191:             {skip, &quot;PropEr not available&quot;};
<a name="192"/>  192:         true -&gt;
<a name="193"/>  193:             Prop = ?FORALL(
<a name="194"/>  194:                 Operations,
<a name="195"/>  195:                 list(operation()),
<a name="196"/>  196:                 begin
<a name="197"/>  197:                     TenantId = &lt;&lt;&quot;prop_index_tenant&quot;&gt;&gt;,
<a name="198"/>  198:                     
<a name="199"/>  199:                     %% Execute operations
<a name="200"/>  200:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="201"/>  201:                     
<a name="202"/>  202:                     %% Get policies via list_policies (uses index)
<a name="203"/>  203:                     {ok, IndexedPolicies} = router_policy_store:list_policies(TenantId),
<a name="204"/>  204:                     IndexedIds = lists:sort([P#policy.policy_id || P &lt;- IndexedPolicies]),
<a name="205"/>  205:                     
<a name="206"/>  206:                     %% Get policies via direct lookup (bypasses index)
<a name="207"/>  207:                     AllKeys = ets:match(policy_store, {{TenantId, '$1'}, '_'}),
<a name="208"/>  208:                     DirectIds = lists:sort([Id || [Id] &lt;- AllKeys]),
<a name="209"/>  209:                     
<a name="210"/>  210:                     %% Check: index and direct lookup should match
<a name="211"/>  211:                     IndexConsistent = IndexedIds =:= DirectIds,
<a name="212"/>  212:                     
<a name="213"/>  213:                     %% Check: for each {TenantId, PolicyId} in main table, there's exactly one entry in index
<a name="214"/>  214:                     IndexTable = policy_store_index,
<a name="215"/>  215:                     AllIndexEntries = ets:match_object(IndexTable, {TenantId, '_'}),
<a name="216"/>  216:                     IndexPolicyIds = lists:sort([PolicyId || {_TenantId, PolicyId} &lt;- AllIndexEntries]),
<a name="217"/>  217:                     
<a name="218"/>  218:                     %% Check: all policies in main table have corresponding index entries
<a name="219"/>  219:                     AllMainPolicies = ets:match_object(policy_store, {{TenantId, '_'}, '_'}),
<a name="220"/>  220:                     MainPolicyIds = lists:sort([PolicyId || {{_TenantId, PolicyId}, _Policy} &lt;- AllMainPolicies]),
<a name="221"/>  221:                     
<a name="222"/>  222:                     IndexComplete = MainPolicyIds =:= IndexPolicyIds,
<a name="223"/>  223:                     
<a name="224"/>  224:                     %% Check: bag index invariants
<a name="225"/>  225:                     %% 1. Each {TenantId, PolicyId} pair appears exactly once in index
<a name="226"/>  226:                     %% Bag allows multiple entries per key, but each {tenant_id, policy_id} pair should be unique
<a name="227"/>  227:                     IndexPairs = [{T, P} || {T, P} &lt;- AllIndexEntries],
<a name="228"/>  228:                     UniquePairs = lists:usort(IndexPairs),
<a name="229"/>  229:                     NoDuplicates = length(IndexPairs) =:= length(UniquePairs),
<a name="230"/>  230:                     
<a name="231"/>  231:                     %% 2. For each policy in main table, there's exactly one index entry
<a name="232"/>  232:                     OneToOne = length(MainPolicyIds) =:= length(IndexPolicyIds),
<a name="233"/>  233:                     
<a name="234"/>  234:                     %% 3. Bag index deletion uses delete_object (not delete)
<a name="235"/>  235:                     %% This ensures that only specific {tenant_id, policy_id} pairs are removed,
<a name="236"/>  236:                     %% not all entries for a tenant_id
<a name="237"/>  237:                     %% Verification: index should only contain pairs that exist in main table
<a name="238"/>  238:                     IndexPairsSet = sets:from_list(IndexPairs),
<a name="239"/>  239:                     MainPairsSet = sets:from_list([{TenantId, PolicyId} || {{_T, PolicyId}, _} &lt;- AllMainPolicies]),
<a name="240"/>  240:                     IndexMatchesMain = sets:is_equal(IndexPairsSet, MainPairsSet),
<a name="241"/>  241:                     
<a name="242"/>  242:                     %% All checks must pass
<a name="243"/>  243:                     IndexConsistent andalso IndexComplete andalso NoDuplicates andalso OneToOne andalso IndexMatchesMain
<a name="244"/>  244:                 end
<a name="245"/>  245:             ),
<a name="246"/>  246:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="247"/>  247:             case Result of
<a name="248"/>  248:                 true -&gt; 
<a name="249"/>  249:                     ok;
<a name="250"/>  250:                 false -&gt;
<a name="251"/>  251:                     ct:fail(&quot;Property failed&quot;);
<a name="252"/>  252:                 {false, CounterExample} -&gt;
<a name="253"/>  253:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="254"/>  254:                 Other -&gt;
<a name="255"/>  255:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="256"/>  256:             end
<a name="257"/>  257:     end.
<a name="258"/>  258: 
<a name="259"/>  259: <i>%% Generators</i>
<a name="260"/>  260: 
<a name="operation-0"/><a name="261"/>  261: <b>operation</b>() -&gt;
<a name="operation-last_expr"/><a name="262"/>  262: <b>    oneof</b>([
<a name="263"/>  263:         upsert_operation(),
<a name="264"/>  264:         delete_operation()
<a name="265"/>  265:     ]).
<a name="266"/>  266: 
<a name="upsert_operation-0"/><a name="267"/>  267: <b>upsert_operation</b>() -&gt;
<a name="upsert_operation-last_expr"/><a name="268"/>  268: <b>    ?LET</b>(
<a name="269"/>  269:         {PolicyId, Weights},
<a name="270"/>  270:         {policy_id(), weights()},
<a name="271"/>  271:         {upsert, #policy{
<a name="272"/>  272:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="273"/>  273:             policy_id = PolicyId,
<a name="274"/>  274:             weights = Weights,
<a name="275"/>  275:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="276"/>  276:             defaults = #{},
<a name="277"/>  277:             escalate_on = [],
<a name="278"/>  278:             fallback = undefined,
<a name="279"/>  279:             sticky = undefined,
<a name="280"/>  280:             metadata = #{}
<a name="281"/>  281:         }}
<a name="282"/>  282:     ).
<a name="283"/>  283: 
<a name="delete_operation-0"/><a name="284"/>  284: <b>delete_operation</b>() -&gt;
<a name="delete_operation-last_expr"/><a name="285"/>  285: <b>    ?LET</b>(
<a name="286"/>  286:         PolicyId,
<a name="287"/>  287:         policy_id(),
<a name="288"/>  288:         {delete, PolicyId}
<a name="289"/>  289:     ).
<a name="290"/>  290: 
<a name="policy-0"/><a name="291"/>  291: <b>policy</b>() -&gt;
<a name="policy-last_expr"/><a name="292"/>  292: <b>    ?LET</b>(
<a name="293"/>  293:         {PolicyId, Weights},
<a name="294"/>  294:         {policy_id(), weights()},
<a name="295"/>  295:         #policy{
<a name="296"/>  296:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="297"/>  297:             policy_id = PolicyId,
<a name="298"/>  298:             weights = Weights,
<a name="299"/>  299:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="300"/>  300:             defaults = #{},
<a name="301"/>  301:             escalate_on = [],
<a name="302"/>  302:             fallback = undefined,
<a name="303"/>  303:             sticky = undefined,
<a name="304"/>  304:             metadata = #{}
<a name="305"/>  305:         }
<a name="306"/>  306:     ).
<a name="307"/>  307: 
<a name="policy_id-0"/><a name="308"/>  308: <b>policy_id</b>() -&gt;
<a name="policy_id-last_expr"/><a name="309"/>  309: <b>    ?LET</b>(
<a name="310"/>  310:         N,
<a name="311"/>  311:         integer(1, 1000),
<a name="312"/>  312:         list_to_binary(&quot;policy_&quot; ++ integer_to_list(N))
<a name="313"/>  313:     ).
<a name="314"/>  314: 
<a name="weights-0"/><a name="315"/>  315: <b>weights</b>() -&gt;
<a name="weights-last_expr"/><a name="316"/>  316: <b>    ?LET</b>(
<a name="317"/>  317:         Providers,
<a name="318"/>  318:         list({provider_id(), weight()}),
<a name="319"/>  319:         maps:from_list(Providers)
<a name="320"/>  320:     ).
<a name="321"/>  321: 
<a name="provider_id-0"/><a name="322"/>  322: <b>provider_id</b>() -&gt;
<a name="provider_id-last_expr"/><a name="323"/>  323: <b>    oneof</b>([&lt;&lt;&quot;openai&quot;&gt;&gt;, &lt;&lt;&quot;anthropic&quot;&gt;&gt;, &lt;&lt;&quot;cohere&quot;&gt;&gt;]).
<a name="324"/>  324: 
<a name="weight-0"/><a name="325"/>  325: <b>weight</b>() -&gt;
<a name="weight-last_expr"/><a name="326"/>  326: <b>    ?LET</b>(
<a name="327"/>  327:         W,
<a name="328"/>  328:         real(),
<a name="329"/>  329:         max(0.0, min(1.0, abs(W)))
<a name="330"/>  330:     ).
<a name="331"/>  331: 
<a name="332"/>  332: <i>%% Helpers</i>
<a name="333"/>  333: 
<a name="execute_operation-2"/><a name="334"/>  334: <b>execute_operation</b>(TenantId, {upsert, Policy}) -&gt;
<a name="335"/>  335:     router_policy_store:upsert_policy(TenantId, Policy);
<a name="336"/>  336: <b>execute_operation</b>(TenantId, {delete, PolicyId}) -&gt;
<a name="execute_operation-last_expr"/><a name="337"/>  337: <b>    router_policy_store:delete_policy</b>(TenantId, PolicyId).
<a name="338"/>  338: 
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
