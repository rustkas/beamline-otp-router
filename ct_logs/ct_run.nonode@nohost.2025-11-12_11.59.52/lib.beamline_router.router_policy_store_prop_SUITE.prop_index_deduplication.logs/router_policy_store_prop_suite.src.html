<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/home/rustkas/aigroup/apps/otp/router/_build/test/lib/beamline_router/test/router_policy_store_prop_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%% @doc Property-based tests for router_policy_store</i>
<a name="2"/>    2: <i>%% Uses PropEr for randomized sequence of operations to detect race conditions</i>
<a name="3"/>    3: <b>-module</b>(router_policy_store_prop_SUITE).
<a name="4"/>    4: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="5"/>    5: 
<a name="6"/>    6: <i>%% Always include proper.hrl in test profile (PropEr is available in test profile)</i>
<a name="7"/>    7: <i>%% Runtime check for PropEr availability is done in prop_* functions</i>
<a name="8"/>    8: <b>-include_lib</b>(&quot;proper/include/proper.hrl&quot;).
<a name="9"/>    9: 
<a name="10"/>   10: <b>-compile</b>(export_all).
<a name="11"/>   11: 
<a name="12"/>   12: <b>-export</b>([all/0, init_per_suite/1, end_per_suite/1]).
<a name="13"/>   13: 
<a name="14"/>   14: <b>-include</b>(&quot;beamline_router.hrl&quot;).
<a name="15"/>   15: 
<a name="all-0"/><a name="16"/>   16: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="17"/>   17: <b>    case code:which</b>(proper) of
<a name="18"/>   18:         non_existing -&gt; [
<a name="19"/>   19:             prop_concurrent_operations_skip,
<a name="20"/>   20:             prop_upsert_delete_consistency_skip,
<a name="21"/>   21:             prop_list_policies_ordering_skip,
<a name="22"/>   22:             prop_index_consistency_skip,
<a name="23"/>   23:             prop_index_deduplication_skip
<a name="24"/>   24:         ];
<a name="25"/>   25:         _ -&gt; [
<a name="26"/>   26:             prop_concurrent_operations,
<a name="27"/>   27:             prop_upsert_delete_consistency,
<a name="28"/>   28:             prop_list_policies_ordering,
<a name="29"/>   29:             prop_index_consistency
<a name="30"/>   30:             %% TODO: prop_index_deduplication - requires investigation of bag table behavior
<a name="31"/>   31:             %% prop_index_deduplication
<a name="32"/>   32:         ]
<a name="33"/>   33:     end.
<a name="34"/>   34: 
<a name="init_per_suite-1"/><a name="35"/>   35: <b>init_per_suite</b>(Config) -&gt;
<a name="36"/>   36:     %% Start application with ephemeral port
<a name="37"/>   37:     _ = application:load(beamline_router),
<a name="38"/>   38:     ok = application:set_env(beamline_router, grpc_port, 0),
<a name="39"/>   39:     %% Disable heir/transfer logic for faster test execution
<a name="40"/>   40:     ok = application:set_env(beamline_router, disable_heir, true),
<a name="41"/>   41:     ok = application:set_env(beamline_router, grpc_enabled, false),
<a name="42"/>   42:     ok = application:set_env(beamline_router, nats_mode, mock),
<a name="init_per_suite-last_expr"/><a name="43"/>   43: <b>    case application:ensure_all_started</b>(beamline_router) of
<a name="44"/>   44:         {ok, _} -&gt;
<a name="45"/>   45:             Config;
<a name="46"/>   46:         Error -&gt;
<a name="47"/>   47:             ct:fail(&quot;Failed to start beamline_router: ~p&quot;, [Error])
<a name="48"/>   48:     end.
<a name="49"/>   49: 
<a name="end_per_suite-1"/><a name="50"/>   50: <b>end_per_suite</b>(_Config) -&gt;
<a name="51"/>   51:     application:stop(beamline_router),
<a name="end_per_suite-last_expr"/><a name="52"/>   52:     ok.
<a name="53"/>   53: 
<a name="54"/>   54: <i>%% Skip tests if PropEr not available</i>
<a name="prop_concurrent_operations_skip-1"/><a name="55"/>   55: <b>prop_concurrent_operations_skip</b>(_Config) -&gt;
<a name="prop_concurrent_operations_skip-last_expr"/><a name="56"/>   56:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_upsert_delete_consistency_skip-1"/><a name="57"/>   57: <b>prop_upsert_delete_consistency_skip</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency_skip-last_expr"/><a name="58"/>   58:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_list_policies_ordering_skip-1"/><a name="59"/>   59: <b>prop_list_policies_ordering_skip</b>(_Config) -&gt;
<a name="prop_list_policies_ordering_skip-last_expr"/><a name="60"/>   60:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_index_consistency_skip-1"/><a name="61"/>   61: <b>prop_index_consistency_skip</b>(_Config) -&gt;
<a name="prop_index_consistency_skip-last_expr"/><a name="62"/>   62:     {skip, &quot;PropEr not available&quot;}.
<a name="prop_index_deduplication_skip-1"/><a name="63"/>   63: <b>prop_index_deduplication_skip</b>(_Config) -&gt;
<a name="prop_index_deduplication_skip-last_expr"/><a name="64"/>   64:     {skip, &quot;PropEr not available&quot;}.
<a name="65"/>   65: 
<a name="66"/>   66: <i>%% Property: Concurrent operations maintain consistency</i>
<a name="prop_concurrent_operations-1"/><a name="67"/>   67: <b>prop_concurrent_operations</b>(_Config) -&gt;
<a name="prop_concurrent_operations-last_expr"/><a name="68"/>   68: <b>    case code:which</b>(proper) of
<a name="69"/>   69:         non_existing -&gt;
<a name="70"/>   70:             {skip, &quot;PropEr not available&quot;};
<a name="71"/>   71:         _ -&gt;
<a name="72"/>   72:             Prop = ?FORALL(
<a name="73"/>   73:                 Operations,
<a name="74"/>   74:                 list(operation()),
<a name="75"/>   75:                 begin
<a name="76"/>   76:                     TenantId = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="77"/>   77:                     %% Execute operations sequentially (gen_server serializes)
<a name="78"/>   78:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="79"/>   79:                     
<a name="80"/>   80:                     %% Verify final state is consistent
<a name="81"/>   81:                     {ok, FinalPolicies} = router_policy_store:list_policies(TenantId),
<a name="82"/>   82:                     
<a name="83"/>   83:                     %% Check: all policies in list should be valid
<a name="84"/>   84:                     AllValid = lists:all(fun(P) -&gt;
<a name="85"/>   85:                         is_record(P, policy) andalso
<a name="86"/>   86:                         P#policy.tenant_id =:= TenantId
<a name="87"/>   87:                     end, FinalPolicies),
<a name="88"/>   88:                     
<a name="89"/>   89:                     %% Check: no duplicate policy_ids
<a name="90"/>   90:                     PolicyIds = [P#policy.policy_id || P &lt;- FinalPolicies],
<a name="91"/>   91:                     NoDuplicates = length(PolicyIds) =:= length(lists:usort(PolicyIds)),
<a name="92"/>   92:                     
<a name="93"/>   93:                     AllValid andalso NoDuplicates
<a name="94"/>   94:                 end
<a name="95"/>   95:             ),
<a name="96"/>   96:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="97"/>   97:             case Result of
<a name="98"/>   98:                 true -&gt; 
<a name="99"/>   99:                     ok;
<a name="100"/>  100:                 false -&gt;
<a name="101"/>  101:                     ct:fail(&quot;Property failed&quot;);
<a name="102"/>  102:                 {false, CounterExample} -&gt;
<a name="103"/>  103:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="104"/>  104:                 Other -&gt;
<a name="105"/>  105:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="106"/>  106:             end
<a name="107"/>  107:     end.
<a name="108"/>  108: 
<a name="109"/>  109: <i>%% Property: Upsert and delete maintain consistency</i>
<a name="prop_upsert_delete_consistency-1"/><a name="110"/>  110: <b>prop_upsert_delete_consistency</b>(_Config) -&gt;
<a name="prop_upsert_delete_consistency-last_expr"/><a name="111"/>  111: <b>    case code:which</b>(proper) of
<a name="112"/>  112:         non_existing -&gt;
<a name="113"/>  113:             {skip, &quot;PropEr not available&quot;};
<a name="114"/>  114:         _ -&gt;
<a name="115"/>  115:             Prop = ?FORALL(
<a name="116"/>  116:                 {Upserts, Deletes},
<a name="117"/>  117:                 {list(upsert_operation()), list(delete_operation())},
<a name="118"/>  118:                 begin
<a name="119"/>  119:                     TenantId = &lt;&lt;&quot;prop_consistency_tenant&quot;&gt;&gt;,
<a name="120"/>  120:                     
<a name="121"/>  121:                     %% Execute all upserts first
<a name="122"/>  122:                     [execute_operation(TenantId, Op) || Op &lt;- Upserts],
<a name="123"/>  123:                     
<a name="124"/>  124:                     %% Get policy IDs from upserts
<a name="125"/>  125:                     UpsertedIds = [Policy#policy.policy_id || {upsert, Policy} &lt;- Upserts],
<a name="126"/>  126:                     
<a name="127"/>  127:                     %% Execute all deletes
<a name="128"/>  128:                     [execute_operation(TenantId, Op) || Op &lt;- Deletes],
<a name="129"/>  129:                     
<a name="130"/>  130:                     %% Get deleted policy IDs
<a name="131"/>  131:                     DeletedIds = [PolicyId || {delete, PolicyId} &lt;- Deletes],
<a name="132"/>  132:                     
<a name="133"/>  133:                     %% Get final state
<a name="134"/>  134:                     {ok, Policies} = router_policy_store:list_policies(TenantId),
<a name="135"/>  135:                     FinalPolicyIds = [P#policy.policy_id || P &lt;- Policies],
<a name="136"/>  136:                     
<a name="137"/>  137:                     %% Check: policies that were deleted and NOT re-upserted should not be in final list
<a name="138"/>  138:                     %% A policy is truly deleted if it was deleted AND not re-upserted after deletion
<a name="139"/>  139:                     TrulyDeleted = [Id || Id &lt;- DeletedIds, not lists:member(Id, UpsertedIds)],
<a name="140"/>  140:                     
<a name="141"/>  141:                     %% Verify: truly deleted policies should not be in final list
<a name="142"/>  142:                     lists:all(fun(DeletedId) -&gt;
<a name="143"/>  143:                         not lists:member(DeletedId, FinalPolicyIds)
<a name="144"/>  144:                     end, TrulyDeleted)
<a name="145"/>  145:                 end
<a name="146"/>  146:             ),
<a name="147"/>  147:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="148"/>  148:             case Result of
<a name="149"/>  149:                 true -&gt; 
<a name="150"/>  150:                     ok;
<a name="151"/>  151:                 false -&gt;
<a name="152"/>  152:                     ct:fail(&quot;Property failed&quot;);
<a name="153"/>  153:                 {false, CounterExample} -&gt;
<a name="154"/>  154:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="155"/>  155:                 Other -&gt;
<a name="156"/>  156:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="157"/>  157:             end
<a name="158"/>  158:     end.
<a name="159"/>  159: 
<a name="160"/>  160: <i>%% Property: list_policies always returns sorted results</i>
<a name="prop_list_policies_ordering-1"/><a name="161"/>  161: <b>prop_list_policies_ordering</b>(_Config) -&gt;
<a name="prop_list_policies_ordering-last_expr"/><a name="162"/>  162: <b>    case code:which</b>(proper) of
<a name="163"/>  163:         non_existing -&gt;
<a name="164"/>  164:             {skip, &quot;PropEr not available&quot;};
<a name="165"/>  165:         _ -&gt;
<a name="166"/>  166:             Prop = ?FORALL(
<a name="167"/>  167:                 Policies,
<a name="168"/>  168:                 list(policy()),
<a name="169"/>  169:                 begin
<a name="170"/>  170:                     TenantId = &lt;&lt;&quot;prop_ordering_tenant&quot;&gt;&gt;,
<a name="171"/>  171:                     
<a name="172"/>  172:                     %% Clear existing policies
<a name="173"/>  173:                     {ok, Existing} = router_policy_store:list_policies(TenantId),
<a name="174"/>  174:                     [router_policy_store:delete_policy(TenantId, P#policy.policy_id) || P &lt;- Existing],
<a name="175"/>  175:                     
<a name="176"/>  176:                     %% Insert all policies
<a name="177"/>  177:                     [router_policy_store:upsert_policy(TenantId, P) || P &lt;- Policies],
<a name="178"/>  178:                     
<a name="179"/>  179:                     %% Get list
<a name="180"/>  180:                     {ok, Listed} = router_policy_store:list_policies(TenantId),
<a name="181"/>  181:                     
<a name="182"/>  182:                     %% Check: results are sorted by policy_id (lexicographic binary order)
<a name="183"/>  183:                     PolicyIds = [P#policy.policy_id || P &lt;- Listed],
<a name="184"/>  184:                     %% Use Erlang term ordering (&lt;) to match implementation
<a name="185"/>  185:                     Sorted = lists:sort(PolicyIds),
<a name="186"/>  186:                     
<a name="187"/>  187:                     PolicyIds =:= Sorted
<a name="188"/>  188:                 end
<a name="189"/>  189:             ),
<a name="190"/>  190:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="191"/>  191:             case Result of
<a name="192"/>  192:                 true -&gt; 
<a name="193"/>  193:                     ok;
<a name="194"/>  194:                 false -&gt;
<a name="195"/>  195:                     ct:fail(&quot;Property failed&quot;);
<a name="196"/>  196:                 {false, CounterExample} -&gt;
<a name="197"/>  197:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="198"/>  198:                 Other -&gt;
<a name="199"/>  199:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="200"/>  200:             end
<a name="201"/>  201:     end.
<a name="202"/>  202: 
<a name="203"/>  203: <i>%% Property: Secondary index maintains consistency with main table</i>
<a name="prop_index_consistency-1"/><a name="204"/>  204: <b>prop_index_consistency</b>(_Config) -&gt;
<a name="prop_index_consistency-last_expr"/><a name="205"/>  205: <b>    case code:which</b>(proper) of
<a name="206"/>  206:         non_existing -&gt;
<a name="207"/>  207:             {skip, &quot;PropEr not available&quot;};
<a name="208"/>  208:         _ -&gt;
<a name="209"/>  209:             Prop = ?FORALL(
<a name="210"/>  210:                 Operations,
<a name="211"/>  211:                 list(operation()),
<a name="212"/>  212:                 begin
<a name="213"/>  213:                     TenantId = &lt;&lt;&quot;prop_index_tenant&quot;&gt;&gt;,
<a name="214"/>  214:                     
<a name="215"/>  215:                     %% Execute operations
<a name="216"/>  216:                     [execute_operation(TenantId, Op) || Op &lt;- Operations],
<a name="217"/>  217:                     
<a name="218"/>  218:                     %% Get policies via list_policies (uses index)
<a name="219"/>  219:                     {ok, IndexedPolicies} = router_policy_store:list_policies(TenantId),
<a name="220"/>  220:                     IndexedIds = lists:sort([P#policy.policy_id || P &lt;- IndexedPolicies]),
<a name="221"/>  221:                     
<a name="222"/>  222:                     %% Get policies via direct lookup (bypasses index)
<a name="223"/>  223:                     AllKeys = ets:match(policy_store, {{TenantId, '$1'}, '_'}),
<a name="224"/>  224:                     DirectIds = lists:sort([Id || [Id] &lt;- AllKeys]),
<a name="225"/>  225:                     
<a name="226"/>  226:                     %% Check: index and direct lookup should match
<a name="227"/>  227:                     IndexConsistent = IndexedIds =:= DirectIds,
<a name="228"/>  228:                     
<a name="229"/>  229:                     %% Check: for each {TenantId, PolicyId} in main table, there's exactly one entry in index
<a name="230"/>  230:                     IndexTable = policy_store_index,
<a name="231"/>  231:                     AllIndexEntries = ets:match_object(IndexTable, {TenantId, '_'}),
<a name="232"/>  232:                     IndexPolicyIds = lists:sort([PolicyId || {_TenantId, PolicyId} &lt;- AllIndexEntries]),
<a name="233"/>  233:                     
<a name="234"/>  234:                     %% Check: all policies in main table have corresponding index entries
<a name="235"/>  235:                     AllMainPolicies = ets:match_object(policy_store, {{TenantId, '_'}, '_'}),
<a name="236"/>  236:                     MainPolicyIds = lists:sort([PolicyId || {{_TenantId, PolicyId}, _Policy} &lt;- AllMainPolicies]),
<a name="237"/>  237:                     
<a name="238"/>  238:                     IndexComplete = MainPolicyIds =:= IndexPolicyIds,
<a name="239"/>  239:                     
<a name="240"/>  240:                     %% Check: bag index invariants
<a name="241"/>  241:                     %% 1. Each {TenantId, PolicyId} pair appears exactly once in index
<a name="242"/>  242:                     %% Bag allows multiple entries per key, but each {tenant_id, policy_id} pair should be unique
<a name="243"/>  243:                     IndexPairs = [{T, P} || {T, P} &lt;- AllIndexEntries],
<a name="244"/>  244:                     UniquePairs = lists:usort(IndexPairs),
<a name="245"/>  245:                     NoDuplicates = length(IndexPairs) =:= length(UniquePairs),
<a name="246"/>  246:                     
<a name="247"/>  247:                     %% 2. For each policy in main table, there's exactly one index entry
<a name="248"/>  248:                     OneToOne = length(MainPolicyIds) =:= length(IndexPolicyIds),
<a name="249"/>  249:                     
<a name="250"/>  250:                     %% 3. Bag index deletion uses delete_object (not delete)
<a name="251"/>  251:                     %% This ensures that only specific {tenant_id, policy_id} pairs are removed,
<a name="252"/>  252:                     %% not all entries for a tenant_id
<a name="253"/>  253:                     %% Verification: index should only contain pairs that exist in main table
<a name="254"/>  254:                     IndexPairsSet = sets:from_list(IndexPairs),
<a name="255"/>  255:                     MainPairsSet = sets:from_list([{TenantId, PolicyId} || {{_T, PolicyId}, _} &lt;- AllMainPolicies]),
<a name="256"/>  256:                     IndexMatchesMain = sets:is_equal(IndexPairsSet, MainPairsSet),
<a name="257"/>  257:                     
<a name="258"/>  258:                     %% All checks must pass
<a name="259"/>  259:                     IndexConsistent andalso IndexComplete andalso NoDuplicates andalso OneToOne andalso IndexMatchesMain
<a name="260"/>  260:                 end
<a name="261"/>  261:             ),
<a name="262"/>  262:             Result = proper:quickcheck(Prop, [{numtests, 100}]),
<a name="263"/>  263:             case Result of
<a name="264"/>  264:                 true -&gt; 
<a name="265"/>  265:                     ok;
<a name="266"/>  266:                 false -&gt;
<a name="267"/>  267:                     ct:fail(&quot;Property failed&quot;);
<a name="268"/>  268:                 {false, CounterExample} -&gt;
<a name="269"/>  269:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="270"/>  270:                 Other -&gt;
<a name="271"/>  271:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="272"/>  272:             end
<a name="273"/>  273:     end.
<a name="274"/>  274: 
<a name="275"/>  275: <i>%% Property: Index deduplication after upsert -&gt; delete -&gt; upsert sequence</i>
<a name="276"/>  276: <i>%% Verifies that bag index table doesn't accumulate duplicates after delete/upsert cycles</i>
<a name="277"/>  277: <i>%% This property ensures that after a delete/upsert cycle, the index has exactly one entry</i>
<a name="prop_index_deduplication-1"/><a name="278"/>  278: <b>prop_index_deduplication</b>(_Config) -&gt;
<a name="prop_index_deduplication-last_expr"/><a name="279"/>  279: <b>    case code:which</b>(proper) of
<a name="280"/>  280:         non_existing -&gt;
<a name="281"/>  281:             {skip, &quot;PropEr not available&quot;};
<a name="282"/>  282:         _ -&gt;
<a name="283"/>  283:             Prop = ?FORALL(
<a name="284"/>  284:                 {PolicyId, Policy},
<a name="285"/>  285:                 {policy_id(), policy()},
<a name="286"/>  286:                 begin
<a name="287"/>  287:                     TenantId = &lt;&lt;&quot;prop_dedup_tenant&quot;&gt;&gt;,
<a name="288"/>  288:                     
<a name="289"/>  289:                     %% Step 1: Upsert policy (creates index entry)
<a name="290"/>  290:                     ok = router_policy_store:upsert_policy(TenantId, Policy#policy{policy_id = PolicyId}),
<a name="291"/>  291:                     
<a name="292"/>  292:                     %% Step 2: Delete policy (removes index entry via match_delete)
<a name="293"/>  293:                     ok = router_policy_store:delete_policy(TenantId, PolicyId),
<a name="294"/>  294:                     
<a name="295"/>  295:                     %% Step 3: Upsert same policy again (should create single index entry, not duplicate)
<a name="296"/>  296:                     ok = router_policy_store:upsert_policy(TenantId, Policy#policy{policy_id = PolicyId}),
<a name="297"/>  297:                     
<a name="298"/>  298:                     %% Verify final state: index should have exactly one entry for this {TenantId, PolicyId} pair
<a name="299"/>  299:                     IndexTable = policy_store_index,
<a name="300"/>  300:                     FinalEntries = ets:match_object(IndexTable, {TenantId, PolicyId}),
<a name="301"/>  301:                     FinalCount = length(FinalEntries),
<a name="302"/>  302:                     
<a name="303"/>  303:                     %% Verify: main table has exactly one entry
<a name="304"/>  304:                     MainEntries = ets:match_object(policy_store, {{TenantId, PolicyId}, '_'}),
<a name="305"/>  305:                     MainCount = length(MainEntries),
<a name="306"/>  306:                     
<a name="307"/>  307:                     %% Verify: list_policies should return exactly one policy
<a name="308"/>  308:                     {ok, ListedPolicies} = router_policy_store:list_policies(TenantId),
<a name="309"/>  309:                     ListedCount = length([P || P &lt;- ListedPolicies, P#policy.policy_id =:= PolicyId]),
<a name="310"/>  310:                     
<a name="311"/>  311:                     %% All checks: final index=1, main=1, listed=1 (no duplicates)
<a name="312"/>  312:                     %% Note: bag table prevents duplicate entries, so FinalCount should always be &lt;= 1
<a name="313"/>  313:                     %% If FinalCount = 0, it means index entry is missing (inconsistency)
<a name="314"/>  314:                     %% If FinalCount &gt; 1, it means duplicates exist (should not happen with bag table)
<a name="315"/>  315:                     (FinalCount =:= 1) andalso
<a name="316"/>  316:                     (MainCount =:= 1) andalso
<a name="317"/>  317:                     (ListedCount =:= 1)
<a name="318"/>  318:                 end
<a name="319"/>  319:             ),
<a name="320"/>  320:             Result = proper:quickcheck(Prop, [{numtests, 50}]),
<a name="321"/>  321:             case Result of
<a name="322"/>  322:                 true -&gt; 
<a name="323"/>  323:                     ok;
<a name="324"/>  324:                 false -&gt;
<a name="325"/>  325:                     ct:fail(&quot;Property failed&quot;);
<a name="326"/>  326:                 {false, CounterExample} -&gt;
<a name="327"/>  327:                     ct:fail(&quot;Property failed with counterexample: ~p&quot;, [CounterExample]);
<a name="328"/>  328:                 Other -&gt;
<a name="329"/>  329:                     ct:fail(&quot;Unexpected result from proper:quickcheck: ~p&quot;, [Other])
<a name="330"/>  330:             end
<a name="331"/>  331:     end.
<a name="332"/>  332: 
<a name="333"/>  333: <i>%% Generators</i>
<a name="334"/>  334: 
<a name="operation-0"/><a name="335"/>  335: <b>operation</b>() -&gt;
<a name="operation-last_expr"/><a name="336"/>  336: <b>    oneof</b>([
<a name="337"/>  337:         upsert_operation(),
<a name="338"/>  338:         delete_operation()
<a name="339"/>  339:     ]).
<a name="340"/>  340: 
<a name="upsert_operation-0"/><a name="341"/>  341: <b>upsert_operation</b>() -&gt;
<a name="upsert_operation-last_expr"/><a name="342"/>  342: <b>    ?LET</b>(
<a name="343"/>  343:         {PolicyId, Weights},
<a name="344"/>  344:         {policy_id(), weights()},
<a name="345"/>  345:         {upsert, #policy{
<a name="346"/>  346:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="347"/>  347:             policy_id = PolicyId,
<a name="348"/>  348:             weights = Weights,
<a name="349"/>  349:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="350"/>  350:             defaults = #{},
<a name="351"/>  351:             escalate_on = [],
<a name="352"/>  352:             fallback = undefined,
<a name="353"/>  353:             sticky = undefined,
<a name="354"/>  354:             metadata = #{}
<a name="355"/>  355:         }}
<a name="356"/>  356:     ).
<a name="357"/>  357: 
<a name="delete_operation-0"/><a name="358"/>  358: <b>delete_operation</b>() -&gt;
<a name="delete_operation-last_expr"/><a name="359"/>  359: <b>    ?LET</b>(
<a name="360"/>  360:         PolicyId,
<a name="361"/>  361:         policy_id(),
<a name="362"/>  362:         {delete, PolicyId}
<a name="363"/>  363:     ).
<a name="364"/>  364: 
<a name="policy-0"/><a name="365"/>  365: <b>policy</b>() -&gt;
<a name="policy-last_expr"/><a name="366"/>  366: <b>    ?LET</b>(
<a name="367"/>  367:         {PolicyId, Weights},
<a name="368"/>  368:         {policy_id(), weights()},
<a name="369"/>  369:         #policy{
<a name="370"/>  370:             tenant_id = &lt;&lt;&quot;prop_tenant&quot;&gt;&gt;,
<a name="371"/>  371:             policy_id = PolicyId,
<a name="372"/>  372:             weights = Weights,
<a name="373"/>  373:             version = &lt;&lt;&quot;1.0&quot;&gt;&gt;,
<a name="374"/>  374:             defaults = #{},
<a name="375"/>  375:             escalate_on = [],
<a name="376"/>  376:             fallback = undefined,
<a name="377"/>  377:             sticky = undefined,
<a name="378"/>  378:             metadata = #{}
<a name="379"/>  379:         }
<a name="380"/>  380:     ).
<a name="381"/>  381: 
<a name="policy_id-0"/><a name="382"/>  382: <b>policy_id</b>() -&gt;
<a name="policy_id-last_expr"/><a name="383"/>  383: <b>    ?LET</b>(
<a name="384"/>  384:         N,
<a name="385"/>  385:         integer(1, 1000),
<a name="386"/>  386:         list_to_binary(&quot;policy_&quot; ++ integer_to_list(N))
<a name="387"/>  387:     ).
<a name="388"/>  388: 
<a name="weights-0"/><a name="389"/>  389: <b>weights</b>() -&gt;
<a name="weights-last_expr"/><a name="390"/>  390: <b>    ?LET</b>(
<a name="391"/>  391:         Providers,
<a name="392"/>  392:         list({provider_id(), weight()}),
<a name="393"/>  393:         maps:from_list(Providers)
<a name="394"/>  394:     ).
<a name="395"/>  395: 
<a name="provider_id-0"/><a name="396"/>  396: <b>provider_id</b>() -&gt;
<a name="provider_id-last_expr"/><a name="397"/>  397: <b>    oneof</b>([&lt;&lt;&quot;openai&quot;&gt;&gt;, &lt;&lt;&quot;anthropic&quot;&gt;&gt;, &lt;&lt;&quot;cohere&quot;&gt;&gt;]).
<a name="398"/>  398: 
<a name="weight-0"/><a name="399"/>  399: <b>weight</b>() -&gt;
<a name="weight-last_expr"/><a name="400"/>  400: <b>    ?LET</b>(
<a name="401"/>  401:         W,
<a name="402"/>  402:         real(),
<a name="403"/>  403:         max(0.0, min(1.0, abs(W)))
<a name="404"/>  404:     ).
<a name="405"/>  405: 
<a name="406"/>  406: <i>%% Helpers</i>
<a name="407"/>  407: 
<a name="execute_operation-2"/><a name="408"/>  408: <b>execute_operation</b>(TenantId, {upsert, Policy}) -&gt;
<a name="409"/>  409:     router_policy_store:upsert_policy(TenantId, Policy);
<a name="410"/>  410: <b>execute_operation</b>(TenantId, {delete, PolicyId}) -&gt;
<a name="execute_operation-last_expr"/><a name="411"/>  411: <b>    router_policy_store:delete_policy</b>(TenantId, PolicyId).
<a name="412"/>  412: 
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
