-doc "Deployment Automation Module".
%%
%% Provides deployment automation, validation, and rollback procedures.
%% Ensures safe and reliable deployments with validation and rollback capabilities.
%%
%% @see DEPLOYMENT_GUIDE.md For deployment procedures
-module(router_deployment).

-export([deploy/1, validate_deployment/1, rollback/1, get_deployment_status/0,
         get_deployment_history/0, check_pre_deployment/0, check_post_deployment/0]).

%% Deployment state record
-record(deployment_state,
        {version :: binary(),
         timestamp :: integer(),
         status :: atom(),  %% deploying | deployed | failed | rolled_back
         validation_passed :: boolean(),
         rollback_available :: boolean()}).

-doc "Deploy new version".
%% @param Version Binary version identifier
-spec deploy(binary()) -> {ok, map()} | {error, term()}.
deploy(Version) when is_binary(Version) ->
    try
        %% Pre-deployment checks
        case check_pre_deployment() of
            {ok, PreCheckResults} ->
                %% Validate deployment
                case validate_deployment(Version) of
                    {ok, ValidationResults} ->
                        %% Store deployment state
                        DeploymentState =
                            #deployment_state{version = Version,
                                              timestamp = erlang:system_time(millisecond),
                                              status = deploying,
                                              validation_passed = true,
                                              rollback_available = true},
                        store_deployment_state(DeploymentState),

                        %% Perform deployment
                        DeploymentResult = perform_deployment(Version),

                        %% Post-deployment checks
                        case check_post_deployment() of
                            {ok, PostCheckResults} ->
                                %% Update deployment state
                                UpdatedState =
                                    DeploymentState#deployment_state{status = deployed,
                                                                     validation_passed = true},
                                store_deployment_state(UpdatedState),

                                %% Log deployment
                                router_logger:info(~"Deployment completed",
                                                   #{~"version" => Version,
                                                     ~"status" => ~"deployed",
                                                     ~"pre_checks" => PreCheckResults,
                                                     ~"post_checks" => PostCheckResults}),

                                {ok,
                                 #{version => Version,
                                   status => deployed,
                                   pre_checks => PreCheckResults,
                                   validation => ValidationResults,
                                   post_checks => PostCheckResults,
                                   deployment_result => DeploymentResult}};
                            {error, PostCheckReason} ->
                                %% Deployment failed post-checks, rollback
                                rollback(Version),
                                {error, {post_deployment_check_failed, PostCheckReason}}
                        end;
                    {error, ValidationReason} ->
                        {error, {validation_failed, ValidationReason}}
                end;
            {error, PreCheckReason} ->
                {error, {pre_deployment_check_failed, PreCheckReason}}
        end
    catch
        Class:Reason:Stack ->
            router_logger:error(~"Deployment failed",
                                #{~"version" => Version, ~"error" => {Class, Reason, Stack}}),
            {error, {deployment_exception, Class, Reason, Stack}}
    end.

-doc "Validate deployment".
%% @param Version Binary version identifier
-spec validate_deployment(binary()) -> {ok, map()} | {error, term()}.
validate_deployment(Version) when is_binary(Version) ->
    try
        %% Check version format
        case validate_version_format(Version) of
            true ->
                %% Check application health
                HealthCheck = check_application_health(),

                %% Check configuration
                ConfigCheck = check_configuration(),

                %% Check dependencies
                DepsCheck = check_dependencies(),

                %% Check resources
                ResourcesCheck = check_resources(),

                AllChecksPassed =
                    maps:get(passed, HealthCheck, false)
                    andalso maps:get(passed, ConfigCheck, false)
                    andalso maps:get(passed, DepsCheck, false)
                    andalso maps:get(passed, ResourcesCheck, false),

                Results =
                    #{version_format => valid,
                      health => HealthCheck,
                      configuration => ConfigCheck,
                      dependencies => DepsCheck,
                      resources => ResourcesCheck,
                      passed => AllChecksPassed},

                case AllChecksPassed of
                    true ->
                        {ok, Results};
                    false ->
                        {error, {validation_failed, Results}}
                end;
            false ->
                {error, invalid_version_format}
        end
    catch
        Class:Reason ->
            {error, {validation_exception, Class, Reason}}
    end.

-doc "Rollback to previous version".
%% @param Version Binary version identifier (optional, rolls back to previous if undefined)
-spec rollback(binary() | undefined) -> {ok, map()} | {error, term()}.
rollback(undefined) ->
    %% Rollback to previous version
    case get_previous_deployment() of
        {ok, PreviousVersion} ->
            rollback(PreviousVersion);
        {error, Reason} ->
            {error, {no_previous_version, Reason}}
    end;
rollback(Version) when is_binary(Version) ->
    try
        %% Check if rollback is available
        case check_rollback_available(Version) of
            true ->
                %% Perform rollback
                RollbackResult = perform_rollback(Version),

                %% Update deployment state
                RollbackState =
                    #deployment_state{version = Version,
                                      timestamp = erlang:system_time(millisecond),
                                      status = rolled_back,
                                      validation_passed = true,
                                      rollback_available = false},
                store_deployment_state(RollbackState),

                %% Log rollback
                router_logger:warn(~"Deployment rolled back",
                                   #{~"version" => Version, ~"status" => ~"rolled_back"}),

                {ok,
                 #{version => Version,
                   status => rolled_back,
                   rollback_result => RollbackResult}};
            false ->
                {error, rollback_not_available}
        end
    catch
        Class:CatchReason ->
            {error, {rollback_exception, Class, CatchReason}}
    end.

-doc "Get current deployment status".
-spec get_deployment_status() -> {ok, map()} | {error, term()}.
get_deployment_status() ->
    try
        case get_current_deployment_state() of
            {ok, State} ->
                {ok,
                 #{version => State#deployment_state.version,
                   timestamp => State#deployment_state.timestamp,
                   status => State#deployment_state.status,
                   validation_passed => State#deployment_state.validation_passed,
                   rollback_available => State#deployment_state.rollback_available}};
            {error, not_found} ->
                {ok, #{version => undefined, status => not_deployed}};
            {error, Reason} ->
                {error, Reason}
        end
    catch
        Class:CatchReason ->
            {error, {status_exception, Class, CatchReason}}
    end.

-doc "Get deployment history".
-spec get_deployment_history() -> {ok, [map()]} | {error, term()}.
get_deployment_history() ->
    try
        History = get_all_deployment_states(),
        HistoryMaps = [deployment_state_to_map(State) || State <- History],
        {ok, HistoryMaps}
    catch
        Class:CatchReason ->
            {error, {history_exception, Class, CatchReason}}
    end.

-doc "Check pre-deployment conditions".
-spec check_pre_deployment() -> {ok, map()} | {error, term()}.
check_pre_deployment() ->
    try
        %% Check application is running
        AppRunning =
            case application:which_applications() of
                Apps when is_list(Apps) ->
                    lists:keymember(beamline_router, 1, Apps);
                _ ->
                    false
            end,

        %% Check supervisor is running
        SupRunning =
            case whereis(beamline_router_sup) of
                Pid when is_pid(Pid) ->
                    true;
                _ ->
                    false
            end,

        %% Check NATS connection (if enabled)
        NatsCheck = check_nats_connection(),

        %% Check disk space
        DiskCheck = check_disk_space(),

        AllChecksPassed =
            AppRunning
            andalso SupRunning
            andalso maps:get(passed, NatsCheck, false)
            andalso maps:get(passed, DiskCheck, false),

        Results =
            #{application_running => AppRunning,
              supervisor_running => SupRunning,
              nats_connection => NatsCheck,
              disk_space => DiskCheck,
              passed => AllChecksPassed},

        case AllChecksPassed of
            true ->
                {ok, Results};
            false ->
                {error, {pre_deployment_checks_failed, Results}}
        end
    catch
        Class:Reason ->
            {error, {pre_deployment_check_exception, Class, Reason}}
    end.

-doc "Check post-deployment conditions".
-spec check_post_deployment() -> {ok, map()} | {error, term()}.
check_post_deployment() ->
    try
        %% Check application health
        HealthCheck = check_application_health(),

        %% Check gRPC endpoint (if enabled)
        GrpcCheck = check_grpc_endpoint(),

        %% Check metrics endpoint (if enabled)
        MetricsCheck = check_metrics_endpoint(),

        AllChecksPassed =
            maps:get(passed, HealthCheck, false)
            andalso maps:get(passed, GrpcCheck, false)
            andalso maps:get(passed, MetricsCheck, false),

        Results =
            #{health => HealthCheck,
              grpc_endpoint => GrpcCheck,
              metrics_endpoint => MetricsCheck,
              passed => AllChecksPassed},

        case AllChecksPassed of
            true ->
                {ok, Results};
            false ->
                {error, {post_deployment_checks_failed, Results}}
        end
    catch
        Class:Reason ->
            {error, {post_deployment_check_exception, Class, Reason}}
    end.

%% Internal: Validate version format
-spec validate_version_format(binary()) -> boolean().
validate_version_format(Version) when is_binary(Version) ->
    %% Version format: v1.0.0 or 1.0.0
    case re:run(Version, "^v?[0-9]+\\.[0-9]+\\.[0-9]+", [{capture, none}]) of
        match ->
            true;
        nomatch ->
            false
    end;
validate_version_format(_) ->
    false.

%% Internal: Check application health
-spec check_application_health() -> map().
check_application_health() ->
    try
        %% Check if application is running
        AppRunning =
            case application:which_applications() of
                Apps when is_list(Apps) ->
                    lists:keymember(beamline_router, 1, Apps);
                _ ->
                    false
            end,

        %% Check supervisor
        SupRunning =
            case whereis(beamline_router_sup) of
                Pid when is_pid(Pid) ->
                    true;
                _ ->
                    false
            end,

        #{passed => AppRunning andalso SupRunning,
          application_running => AppRunning,
          supervisor_running => SupRunning}
    catch
        _:_ ->
            #{passed => false, error => health_check_failed}
    end.

%% Internal: Check configuration
-spec check_configuration() -> map().
check_configuration() ->
    try
        %% Check required configuration
        RequiredConfig = [{grpc_enabled, boolean}, {nats_mode, atom}],

        ConfigResults =
            lists:foldl(fun({Key, Type}, Acc) ->
                           Value = application:get_env(beamline_router, Key, undefined),
                           Valid =
                               case Value of
                                   undefined -> false;
                                   V when Type =:= boolean -> is_boolean(V);
                                   V when Type =:= atom -> is_atom(V);
                                   _ -> true
                               end,
                           maps:put(Key, Valid, Acc)
                        end,
                        #{},
                        RequiredConfig),

        AllValid = lists:all(fun({_Key, Valid}) -> Valid end, maps:to_list(ConfigResults)),

        #{passed => AllValid, config_results => ConfigResults}
    catch
        _:_ ->
            #{passed => false, error => config_check_failed}
    end.

%% Internal: Check dependencies
-spec check_dependencies() -> map().
check_dependencies() ->
    try
        %% Check if required applications are available
        RequiredApps = [kernel, stdlib, sasl],
        AvailableApps = [App || {App, _, _} <- application:which_applications()],

        MissingApps = [App || App <- RequiredApps, not lists:member(App, AvailableApps)],

        #{passed => length(MissingApps) =:= 0, missing_apps => MissingApps}
    catch
        _:_ ->
            #{passed => false, error => dependency_check_failed}
    end.

%% Internal: Check resources
-spec check_resources() -> map().
check_resources() ->
    try
        %% Check memory
        MemoryCheck = check_memory(),

        %% Check disk space
        DiskCheck = check_disk_space(),

        #{passed =>
              maps:get(passed, MemoryCheck, false) andalso maps:get(passed, DiskCheck, false),
          memory => MemoryCheck,
          disk => DiskCheck}
    catch
        _:_ ->
            #{passed => false, error => resource_check_failed}
    end.

%% Internal: Check NATS connection
-spec check_nats_connection() -> map().
check_nats_connection() ->
    try
        case erlang:function_exported(router_nats, get_connection_status, 0) of
            true ->
                Status = router_nats:get_connection_status(),
                Connected =
                    case Status of
                        connected ->
                            true;
                        _ ->
                            false
                    end,
                #{passed => Connected, status => Status};
            false ->
                #{passed => true, status => not_required}
        end
    catch
        _:_ ->
            #{passed => false, error => nats_check_failed}
    end.

%% Internal: Check disk space
-spec check_disk_space() -> map().
check_disk_space() ->
    try
        %% Check if we have at least 100MB free
        MinFreeMB = 100,
        _ = MinFreeMB,  %% Minimum free space threshold (reserved for future validation)
        case filelib:is_file(".") of
            true ->
                %% Simple check - if we can write, assume space is available
                TestFile = ".deployment_disk_check",
                case file:write_file(TestFile, ~"test") of
                    ok ->
                        file:delete(TestFile),
                        #{passed => true, free_space_mb => unknown};
                    {error, _} ->
                        #{passed => false, error => insufficient_disk_space}
                end;
            false ->
                #{passed => false, error => disk_check_failed}
        end
    catch
        _:_ ->
            #{passed => false, error => disk_check_exception}
    end.

%% Internal: Check memory
-spec check_memory() -> map().
check_memory() ->
    try
        %% Check if we have at least 128MB available (64MB in test mode)
        MemoryInfo = erlang:memory(),
        TotalMemory = proplists:get_value(total, MemoryInfo, 0),
        MinMemory = case os:getenv("ROUTER_DEPLOYMENT_TEST_MODE") of
                        "1" -> 64 * 1024 * 1024;  %% 64MB for tests
                        _ -> 128 * 1024 * 1024     %% 128MB for prod
                    end,

        #{passed => TotalMemory >= MinMemory, total_memory => TotalMemory}
    catch
        _:_ ->
            #{passed => false, error => memory_check_failed}
    end.

%% Internal: Check gRPC endpoint
-spec check_grpc_endpoint() -> map().
check_grpc_endpoint() ->
    try
        GrpcEnabled = application:get_env(beamline_router, grpc_enabled, false),
        case GrpcEnabled of
            true ->
                %% Check if gRPC server is running
                GrpcRunning =
                    case whereis(router_grpc_sup) of
                        Pid when is_pid(Pid) ->
                            true;
                        _ ->
                            false
                    end,
                #{passed => GrpcRunning, enabled => true};
            false ->
                #{passed => true, enabled => false}
        end
    catch
        _:_ ->
            #{passed => false, error => grpc_check_failed}
    end.

%% Internal: Check metrics endpoint
-spec check_metrics_endpoint() -> map().
check_metrics_endpoint() ->
    try
        MetricsEnabled = application:get_env(beamline_router, metrics_export_enabled, false),
        case MetricsEnabled of
            true ->
                %% Check if metrics endpoint is available
                MetricsAvailable =
                    try
                        _Port = application:get_env(beamline_router, metrics_port, 9001),
                        true
                    catch
                        _:_ ->
                            false
                    end,
                #{passed => MetricsAvailable, enabled => true};
            false ->
                #{passed => true, enabled => false}
        end
    catch
        _:_ ->
            #{passed => false, error => metrics_check_failed}
    end.

%% Internal: Perform deployment
-spec perform_deployment(binary()) -> map().
perform_deployment(Version) ->
    %% In a real deployment, this would:
    %% 1. Stop the application
    %% 2. Update code
    %% 3. Start the application
    %% For now, we just log it
    #{version => Version,
      deployment_time_ms => 0,
      status => deployed}.

%% Internal: Perform rollback
-spec perform_rollback(binary()) -> map().
perform_rollback(Version) ->
    %% In a real rollback, this would:
    %% 1. Stop the application
    %% 2. Restore previous version
    %% 3. Start the application
    %% For now, we just log it
    #{version => Version,
      rollback_time_ms => 0,
      status => rolled_back}.

%% Internal: Check if rollback is available
-spec check_rollback_available(binary()) -> boolean().
check_rollback_available(Version) ->
    _ = Version,  %% Version parameter reserved for future version-specific rollback checks
    %% Check if previous deployment state exists
    case get_previous_deployment() of
        {ok, _PreviousVersion} ->
            true;
        {error, _} ->
            false
    end.

%% Internal: Store deployment state
-spec store_deployment_state(#deployment_state{}) -> ok.
store_deployment_state(State) ->
    %% Store in ETS table (in production, use persistent storage)
    ensure_deployment_table(),
    Key = {deployment, State#deployment_state.version},
    ets:insert(deployment_history, {Key, State}),
    ok.

%% Internal: Get current deployment state
-spec get_current_deployment_state() -> {ok, #deployment_state{}} | {error, term()}.
get_current_deployment_state() ->
    ensure_deployment_table(),
    case ets:last(deployment_history) of
        '$end_of_table' ->
            {error, not_found};
        Key ->
            case ets:lookup(deployment_history, Key) of
                [{_K, State}] ->
                    {ok, State};
                [] ->
                    {error, not_found}
            end
    end.

%% Internal: Get previous deployment
-spec get_previous_deployment() -> {ok, binary()} | {error, term()}.
get_previous_deployment() ->
    ensure_deployment_table(),
    case ets:prev(deployment_history, ets:last(deployment_history)) of
        '$end_of_table' ->
            {error, no_previous_version};
        PrevKey ->
            {deployment, Version} = PrevKey,
            {ok, Version}
    end.

%% Internal: Get all deployment states
-spec get_all_deployment_states() -> [#deployment_state{}].
get_all_deployment_states() ->
    ensure_deployment_table(),
    ets:foldl(fun({_Key, State}, Acc) -> [State | Acc] end, [], deployment_history).

%% Internal: Ensure deployment table exists
-spec ensure_deployment_table() -> ok.
ensure_deployment_table() ->
    try
        case ets:info(deployment_history, name) of
            undefined ->
                ets:new(deployment_history, [ordered_set, named_table, public]);
            _ ->
                ok
        end
    catch
        _:_ ->
            ok
    end.

%% Internal: Convert deployment state to map
-spec deployment_state_to_map(#deployment_state{}) -> map().
deployment_state_to_map(State) ->
    #{version => State#deployment_state.version,
      timestamp => State#deployment_state.timestamp,
      status => State#deployment_state.status,
      validation_passed => State#deployment_state.validation_passed,
      rollback_available => State#deployment_state.rollback_available}.
